<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PQnet</name>
    </assembly>
    <members>
        <member name="T:PQnet.IEncapsulate">
            <summary>
            Interface for signature algorithms
            </summary>
        </member>
        <member name="P:PQnet.IEncapsulate.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.IEncapsulate.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.IEncapsulate.CiphertextBytes">
            <summary>
            Gets the size, in bytes, of the ciphertext
            </summary>
        </member>
        <member name="P:PQnet.IEncapsulate.Name">
            <summary>
            Gets name of the algorithm
            </summary>
        </member>
        <member name="M:PQnet.IEncapsulate.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:PQnet.IEncapsulate.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.IEncapsulate.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.IEncapsulate.Encapsulate(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Use the public (encapsulation) key to generate a shared secret key and an associated ciphertext.
            </summary>
            <param name="public_key">The public (encapsulation) key to use</param>
            <param name="shared_secret_key">Receives the shared secret key</param>
            <param name="ciphertext">Receives the ciphertet</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The public (encapsulation) key length did not match the required <see cref="P:PQnet.IEncapsulate.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.IEncapsulate.Encapsulate(System.Byte[],System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Use the public (encapsulation) key to generate a shared secret key and an associated ciphertext.
            </summary>
            <param name="public_key">The public (encapsulation) key to use</param>
            <param name="shared_secret_key">Receives the shared secret key</param>
            <param name="ciphertext">Receives the ciphertet</param>
            <param name="error">Receives an error description, or <c>null</c></param>
            <returns><c>true</c> on success, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.IEncapsulate.Decapsulate(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Use the private (decapsulation) key to produce a shared secret key from a ciphertext
            </summary>
            <param name="private_key">The private (decapsulation) key to use</param>
            <param name="ciphertext">The ciphertext</param>
            <param name="shared_secret_key">Receives the shared_secret key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The private (decapsulation) key length did not match the required <see cref="P:PQnet.IEncapsulate.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.IEncapsulate.Decapsulate(System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Use the private (decapsulation) key to produce a shared secret key from a ciphertext
            </summary>
            <param name="private_key">The private (decapsulation) key to use</param>
            <param name="ciphertext">The ciphertext</param>
            <param name="shared_secret_key">Receives the shared_secret key</param>
            <param name="error">Receives an error description, or <c>null</c></param>
            <returns><c>true</c> on success, <c>false</c> otherwise</returns>
        </member>
        <member name="T:PQnet.ISecurityCategory">
            <summary>
            Interface for cryptographic algorithms to indicate the NIST security category.
            </summary>
        </member>
        <member name="P:PQnet.ISecurityCategory.NistSecurityCategory">
            <summary>
            Gets the NIST security category of the cryptographic algorithm.
            </summary>
        </member>
        <member name="T:PQnet.ISignature">
            <summary>
            Interface for signature algorithms
            </summary>
        </member>
        <member name="P:PQnet.ISignature.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.ISignature.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.ISignature.SignatureBytes">
            <summary>
            Gets the size, in bytes, of the signature
            </summary>
        </member>
        <member name="P:PQnet.ISignature.Name">
            <summary>
            Gets name of the algorithm
            </summary>
        </member>
        <member name="M:PQnet.ISignature.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:PQnet.ISignature.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.Sign(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Private key length did not match the required <see cref="P:PQnet.ISignature.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or private key length did not match the required <see cref="P:PQnet.ISignature.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Generate a pure signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.SignHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Private key length did not match the required <see cref="P:PQnet.ISignature.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or private key length did not match the required <see cref="P:PQnet.ISignature.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@,System.String@)">
            <summary>
            Generate a signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.Verify(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Public key length did not match the required <see cref="P:PQnet.ISignature.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or the public key length did not match the required <see cref="P:PQnet.ISignature.PublicKeyBytes"/></exception>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.String@)">
            <summary>
            Verify a pure signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.VerifyHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The public key length did not match the required <see cref="P:PQnet.ISignature.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or the public key length did not match the required <see cref="P:PQnet.ISignature.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[],System.String@)">
            <summary>
            Verify a digest ("pre-hash") signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="T:PQnet.PreHashFunction">
            <summary>
            Pre-Hash Functions
             FIPS 204 Section 5.4.1
             FIPS 205 Section 10.2.2 
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA256">
            <summary>
            SHA-256
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA512">
            <summary>
            SHA-512
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHAKE128">
            <summary>
            SHAKE-128
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHAKE256">
            <summary>
            SHAKE-256
            </summary>
        </member>
        <member name="T:PQnet.MlDsa44">
            <summary>
            Implements the ML-DSA-44 signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa44.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa44"/> class with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa44.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa44"/> class.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.MlDsa44.Deterministic">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa44.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa44.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlDsa65">
            <summary>
            Implements the ML-DSA-65 signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa65.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa65"/> class with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa65.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa65"/> class.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.MlDsa65.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa65.Deterministic">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa65.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlDsa87">
            <summary>
            Implements the ML-DSA-87 signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa87.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa87"/> class with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa87.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa87"/> class.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.MlDsa87.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa87.Deterministic">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa87.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlDsaBase">
            <summary>
            Base class for ML-DSA digital signature algorithms.
            </summary>
        </member>
        <member name="F:PQnet.MlDsaBase.SeedBytes">
            <summary>
            The size, in bytes, of the seed used for key generation
            </summary>
        </member>
        <member name="M:PQnet.MlDsaBase.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.MlDsaBase"/> class.
            </summary>
            <param name="K"></param>
            <param name="L"></param>
            <param name="Eta"></param>
            <param name="Tau"></param>
            <param name="Beta"></param>
            <param name="Gamma1"></param>
            <param name="Gamma2"></param>
            <param name="Omega"></param>
            <param name="CTildeBytes"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:PQnet.MlDsaBase.Deterministic">
            <summary>
            Gets whether the signature should be randomized or deterministic (predictable, same input causes same signature)
            </summary>
        </member>
        <member name="P:PQnet.MlDsaBase.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsaBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsaBase.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.MlDsaBase.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.MlDsaBase.SignatureBytes">
            <summary>
            Gets the size, in bytes, of the signature
            </summary>
        </member>
        <member name="M:PQnet.MlDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a ML-DSA key pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a ML-DSA key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a ML-DSA key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
            <remarks>
            If <paramref name="seed"/> is provided, it must be exactly <see cref="F:PQnet.MlDsaBase.SeedBytes"/> bytes long.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Private key length did not match the required <see cref="P:PQnet.MlDsaBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or private key length did not match the required <see cref="P:PQnet.MlDsaBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.SignHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Private key length did not match the required <see cref="P:PQnet.MlDsaBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or private key length did not match the required <see cref="P:PQnet.MlDsaBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@,System.String@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Public key length did not match the required <see cref="P:PQnet.MlDsaBase.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or the public key length did not match the required <see cref="P:PQnet.MlDsaBase.PublicKeyBytes"/></exception>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.String@)">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.VerifyHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The public key length did not match the required <see cref="P:PQnet.MlDsaBase.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or the public key length did not match the required <see cref="P:PQnet.MlDsaBase.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[],System.String@)">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.ntt(System.Int32[])">
            <summary>
            Forward NTT, in-place.
            </summary>
            <param name="a">input/output coefficient array</param>
            <remarks>
            No modular reduction is performed after additions or subtractions.
            Output vector is in bitreversed order.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.invntt_tomont(System.Int32[])">
            <summary>
            Inverse NTT and multiplication by Montgomery factor 2^32.
            </summary>
            <remarks>
            In-place. No modular reductions after additions or subtractions; input coefficients need to be smaller than
            Q in absolute value.Output coefficient are smaller than Q in absolute value
            </remarks>
            <param name="a"></param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_reduce(PQnet.MlDsaBase.Poly)">
            <summary>
            Inplace reduction of all coefficients of polynomial to representative in [-6283008,6283008].
            </summary>
            <param name="a">polynominal</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_caddq(PQnet.MlDsaBase.Poly)">
            <summary>
            For all coefficients of in/out polynomial add Q if coefficient is negative.
            </summary>
            <param name="a">polynominal</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_add(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Add polynomials. No modular reduction is performed.
            </summary>
            <param name="c">Output polynominal</param>
            <param name="a">First summand</param>
            <param name="b">Second summand</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_sub(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Subtract polynomials. No modular reduction is performed.
            </summary>
            <param name="c">Output polynominal</param>
            <param name="a">First polynominal</param>
            <param name="b">Second polynominal to be subtracted from first</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_shiftl(PQnet.MlDsaBase.Poly)">
            <summary>
            Multiply polynomial by 2^D without modular reduction. 
            </summary>
            <param name="a">Polynominal</param>
            <remarks>
            Multiply polynomial by 2^D without modular reduction. 
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_ntt(PQnet.MlDsaBase.Poly)">
            <summary>
            Inplace forward NTT. Coefficients can grow by 8*Q in absolute value.
            </summary>
            <param name="a">Polynominal</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_invntt_tomont(PQnet.MlDsaBase.Poly)">
            <summary>
            Inplace inverse NTT and multiplication by 2^{32}.
            </summary>
            <param name="a"></param>
            <remarks>
            Input coefficients need to be less than Q in absolute value and output coefficients are again bounded by Q.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_pointwise_montgomery(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Pointwise multiplication of polynomials in NTT domain representation and multiplication of resulting polynomial by 2^{-32}.
            </summary>
            <param name="c">Output polynominal</param>
            <param name="a">First polynominal</param>
            <param name="b">Second polynominal</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_power2round(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            For all coefficients c of the input polynomial, compute c0, c1 such that c mod Q = c1*2^D + c0 with -2^{D-1} &lt; c0 &lt;= 2^{D-1}. 
            </summary>
            <param name="a1">polynomial with coefficients c1</param>
            <param name="a0">polynomial with coefficients c0</param>
            <param name="a">input polynomial</param>
            <remarks>
            Assumes coefficients to be standard representatives.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_decompose(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            For all coefficients c of the input polynomial, compute high and low bits c0, c1 such c mod Q = c1*ALPHA + c0 with -ALPHA/2 &lt; c0 &lt;= ALPHA/2 except c1 = (Q-1)/ALPHA where we set c1 = 0 and -ALPHA/2 &lt;= c0 = c mod Q - Q &lt; 0.
            </summary>
            <param name="a1"></param>
            <param name="a0"></param>
            <param name="a"></param>
            <remarks>
            Assumes coefficients to be standard representatives.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_make_hint(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Compute hint polynomial. The coefficients of which indicate whether the low bits of the corresponding coefficient of the input polynomial overflow into the high bits.
            </summary>
            <param name="h">output hint polynomial</param>
            <param name="a0">low part of input polynomial</param>
            <param name="a1">high part of input polynomial</param>
            <returns>number of 1 bits</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_use_hint(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Use hint polynomial to correct the high bits of a polynomial
            </summary>
            <param name="b">output polynomial with corrected high bits</param>
            <param name="a">input polynomial</param>
            <param name="h">input hint polynomial</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_chknorm(PQnet.MlDsaBase.Poly,System.Int32)">
            <summary>
            Check infinity norm of polynomial against given bound.
            </summary>
            <param name="a">polynomial</param>
            <param name="B">norm bound</param>
            <returns>0 if norm is strictly smaller than B &lt;= (Q-1)/8 and 1 otherwise.</returns>
            <remarks>
            Assumes input coefficients were reduced by reduce32().
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.rej_uniform(System.Int32[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Sample uniformly random coefficients in [0, Q-1] by performing rejection sampling on array of random bytes
            </summary>
            <param name="a">output array</param>
            <param name="a_offset">offset in output array</param>
            <param name="len">number of coefficients to be sampled</param>
            <param name="buf">array of random bytes</param>
            <param name="buflen">length of array of random bytes</param>
            <returns></returns>
        </member>
        <member name="M:PQnet.MlDsaBase.montgomery_reduce(System.Int64)">
            <summary>
            Montgomery reduction; given a 64-bit integer a, computes 32-bit integer congruent to a * R^-1 mod Q,
            </summary>
            <param name="a">finite field element a</param>
            <returns>r</returns>
            <remarks>
            For finite field element a with -2^{31}Q &lt;= a &lt;= Q*2^31, compute r \equiv a*2^{-32} (mod Q) such that -Q &lt; r &lt; Q.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.reduce32(System.Int32)">
            <summary>
            Reduce a coefficient a mod Q.
            </summary>
            <param name="a">finite field element a</param>
            <returns>r</returns>
            <remarks>
            For finite field element a with a &lt;= 2^{31} - 2^{22} - 1, compute r \equiv a (mod Q) such that -6283008 &lt;= r &lt;= 6283008.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.caddq(System.Int32)">
            <summary>
            Add Q if input coefficient is negative.
            </summary>
            <param name="a">finite field element a</param>
            <returns>r</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.freeze(System.Int32)">
            <summary>
            
            </summary>
            <param name="a">finite field element a</param>
            <returns>r</returns>
            <remarks>
            For finite field element a, compute standard representative r = a mod^+ Q.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.hash_ml_sign(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction)">
            <summary>
            FIPS 204 Algorithm 4 - Generates a pre-hash ML-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="sk">Private key</param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.MlDsaBase.hash_ml_verify(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            FIPS 204 Algorithm 8 - Verifies a pre-hash ML-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sig">Signature</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="pk">Public key</param>
            <returns><c>true</c> if the signature is valid, <c>false</c> otherwise</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="T:PQnet.MlKemBase">
            <summary>
            Base class for ML-KEM key encapsulation algorithms.
            </summary>
            <summary>
            Base class for ML-KEM key encapsulation algorithms.
            </summary>
        </member>
        <member name="M:PQnet.MlKemBase.crypto_kem_keypair(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="pk"></param>
            <param name="sk"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.MlKemBase.crypto_kem_enc(System.Byte[]@,System.Byte[]@,System.Byte[])">
            <summary>
            
            </summary>
            <param name="ct"></param>
            <param name="ss"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.MlKemBase.crypto_kem_dec(System.Byte[]@,System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="ss"></param>
            <param name="ct"></param>
            <param name="sk"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.MlKemBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a ML-KEM key pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:PQnet.MlKemBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a ML-KEM key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlKemBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a ML-KEM key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed ('d' || 'z') bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
            <remarks>
            If a seed is provided, it must be of 2 *<see cref="P:PQnet.MlKemBase.SeedBytes"/> bytes length.
            </remarks>
        </member>
        <member name="M:PQnet.MlKemBase.Encapsulate(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Use the public (encapsulation) key to generate a shared secret key and an associated ciphertext.
            </summary>
            <param name="public_key">The public (encapsulation) key to use</param>
            <param name="shared_secret_key">Receives the shared secret key</param>
            <param name="ciphertext">Receives the ciphertet</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The public (encapsulation) key length did not match the required <see cref="P:PQnet.MlKemBase.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlKemBase.Encapsulate(System.Byte[],System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Use the public (encapsulation) key to generate a shared secret key and an associated ciphertext.
            </summary>
            <param name="public_key">The public (encapsulation) key to use</param>
            <param name="shared_secret_key">Receives the shared secret key</param>
            <param name="ciphertext">Receives the ciphertet</param>
            <param name="error">Receives an error description, or <c>null</c></param>
            <returns><c>true</c> on success, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlKemBase.Decapsulate(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Use the private (decapsulation) key to produce a shared secret key from a ciphertext
            </summary>
            <param name="private_key">The private (decapsulation) key to use</param>
            <param name="ciphertext">The ciphertext</param>
            <param name="shared_secret_key">Receives the shared_secret key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The private (decapsulation) key length did not match the required <see cref="P:PQnet.MlKemBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlKemBase.Decapsulate(System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Use the private (decapsulation) key to produce a shared secret key from a ciphertext
            </summary>
            <param name="private_key">The private (decapsulation) key to use</param>
            <param name="ciphertext">The ciphertext</param>
            <param name="shared_secret_key">Receives the shared_secret key</param>
            <param name="error">Receives an error description, or <c>null</c></param>
            <returns><c>true</c> on success, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlKemBase.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.MlKemBase"/> class.
            </summary>
            <param name="k"></param>
            <param name="eta_1"></param>
            <param name="eta_2"></param>
            <param name="poly_compressed_bytes"></param>
            <param name="polyvec_compressed_bytes"></param>
        </member>
        <member name="P:PQnet.MlKemBase.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKemBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKemBase.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.MlKemBase.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.MlKemBase.CiphertextBytes">
            <summary>
            Gets the size, in bytes, of the ciphertext
            </summary>
        </member>
        <member name="P:PQnet.MlKemBase.SeedBytes">
            <summary>
            Gets the size, in bytes, of the seed used for key generation
            </summary>
        </member>
        <member name="T:PQnet.MlKem1024">
            <summary>
            Implements the ML-KEM-1024 encapsulation scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlKem1024.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlKem1024"/> class.
            </summary>
        </member>
        <member name="P:PQnet.MlKem1024.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKem1024.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlKem512">
            <summary>
            Implements the ML-KEM-512 encapsulation scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlKem512.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlKem512"/> class.
            </summary>
        </member>
        <member name="P:PQnet.MlKem512.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKem512.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlKem768">
            <summary>
            Implements the ML-KEM-768 encapsulation scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlKem768.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlKem768"/> class.
            </summary>
        </member>
        <member name="P:PQnet.MlKem768.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKem768.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.NamespaceDoc">
            <summary>
            The <c>PQnet</c> namespace contains classes and methods for post-quantum cryptographic algorithms.
            </summary>
        </member>
        <member name="T:PQnet.PQC">
            <summary>
            Provides access to various post-quantum cryptographic algorithms.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlKem512">
            <summary>
            Gets a ML-KEM-512 encapsulation scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlKem768">
            <summary>
            Gets a ML-KEM-768 encapsulation scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlKem1024">
            <summary>
            Gets a ML-KEM-1024 encapsulation scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlDsa44">
            <summary>
            Gets a ML-DSA-44 signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlDsa65">
            <summary>
            Gets a ML-DSA-65 signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlDsa87">
            <summary>
            Gets a ML-DSA-87 signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_128f">
            <summary>
            Gets a SLH-DSA-SHAKE-128f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_128s">
            <summary>
            Gets a SLH-DSA-SHAKE-128s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_192f">
            <summary>
            Gets a SLH-DSA-SHAKE-192f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_192s">
            <summary>
            Gets a SLH-DSA-SHAKE-192s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_256f">
            <summary>
            Gets a SLH-DSA-SHAKE-256f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_256s">
            <summary>
            Gets a SLH-DSA-SHAKE-256s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_128f">
            <summary>
            Gets a SLH-DSA-SHAKE-128f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_128s">
            <summary>
            Gets a SLH-DSA-SHAKE-128s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_192f">
            <summary>
            Gets a SLH-DSA-SHAKE-192f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_192s">
            <summary>
            Gets a SLH-DSA-SHAKE-192s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_256f">
            <summary>
            Gets a SLH-DSA-SHAKE-256f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_256s">
            <summary>
            Gets a SLH-DSA-SHAKE-256s signature scheme object.
            </summary>
        </member>
        <member name="M:PQnet.PQC.GetSignatureAlgorithmInstance(System.String)">
            <summary>
            Return a signature scheme object.
            </summary>
            <param name="name">The name of the signature algorithm</param>
            <returns>An <see cref="T:PQnet.ISignature"/> representing the algorithm <paramref name="name"/></returns>
        </member>
        <member name="M:PQnet.PQC.GetEncapsulationAlgorithmInstance(System.String)">
            <summary>
            Return a encapsulation scheme object.
            </summary>
            <param name="name">The name of the encapsulation algorithm</param>
            <returns>An <see cref="T:PQnet.IEncapsulate"/> representing the algorithm <paramref name="name"/></returns>
        </member>
        <member name="T:PQnet.Rng">
            <summary>
            Cryptographically strong random number generator
            </summary>
        </member>
        <member name="M:PQnet.Rng.randombytes(System.Byte[]@,System.Int32)">
            <summary>
            Generates a random byte array
            </summary>
            <param name="out_buffer">The buffer to receive the random bytes</param>
            <param name="outlen">The number of bytes to generate</param>
        </member>
        <member name="T:PQnet.Digest.Shake">
            <summary>
            Implements the SHA-3 and SHAKE hash functions.
            </summary>
        </member>
        <member name="T:PQnet.Digest.Shake.keccak_state">
            <summary>
            The state of the Keccak sponge function.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake.keccak_state.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Shake.keccak_state"/> class.
            </summary>
        </member>
        <member name="F:PQnet.Digest.Shake.keccak_state.s">
            <summary>
            The state of the Keccak sponge function.
            </summary>
        </member>
        <member name="F:PQnet.Digest.Shake.keccak_state.pos">
            <summary>
            The position in the current block.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake.shake128_init(PQnet.Digest.Shake.keccak_state)">
            <summary>
            Initializes the Keccak state for use as SHAKE128 XOF.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake128_absorb(PQnet.Digest.Shake.keccak_state,System.Byte[],System.Int32)">
            <summary>
            Absorb step of the SHAKE128 XOF; incremental.
            </summary>
            <param name="state"></param>
            <param name="in_buf"></param>
            <param name="inlen"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake128_finalize(PQnet.Digest.Shake.keccak_state)">
            <summary>
            Finalize absorb step of the SHAKE128 XOF.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake128_squeeze(System.Byte[],System.Int32,System.Int32,PQnet.Digest.Shake.keccak_state)">
            <summary>
            Squeeze step of SHAKE128 XOF. Squeezes arbitrarily many bytes.
            </summary>
            <param name="out_buf"></param>
            <param name="out_buf_pos"></param>
            <param name="outlen"></param>
            <param name="state"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake128_absorb_once(PQnet.Digest.Shake.keccak_state,System.Byte[],System.Int32)">
            <summary>
            Initialize, absorb into and finalize SHAKE128 XOF; non-incremental.
            </summary>
            <param name="state"></param>
            <param name="in_buf"></param>
            <param name="inlen"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake128_squeezeblocks(System.Byte[],System.Int32,System.Int32,PQnet.Digest.Shake.keccak_state)">
            <summary>
            Squeeze step of SHAKE128 XOF. Squeezes full blocks of SHAKE128_RATE bytes each.
            </summary>
            <param name="out_buf"></param>
            <param name="out_buf_pos"></param>
            <param name="nblocks"></param>
            <param name="state"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake256_init(PQnet.Digest.Shake.keccak_state)">
            <summary>
            Initializes the Keccak state for use as SHAKE256 XOF.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake256_absorb(PQnet.Digest.Shake.keccak_state,System.Byte[],System.Int32)">
            <summary>
            Absorb step of the SHAKE256 XOF; incremental.
            </summary>
            <param name="state"></param>
            <param name="in_buf"></param>
            <param name="inlen"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake256_finalize(PQnet.Digest.Shake.keccak_state)">
            <summary>
            Finalize absorb step of the SHAKE256 XOF.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake256_squeeze(System.Byte[],System.Int32,System.Int32,PQnet.Digest.Shake.keccak_state)">
            <summary>
            Squeeze step of SHAKE256 XOF. Squeezes arbitrarily many bytes.
            </summary>
            <param name="out_buf"></param>
            <param name="out_buf_pos"></param>
            <param name="outlen"></param>
            <param name="state"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake256_absorb_once(PQnet.Digest.Shake.keccak_state,System.Byte[],System.Int32)">
            <summary>
            Initialize, absorb into and finalize SHAKE256 XOF; non-incremental.
            </summary>
            <param name="state"></param>
            <param name="in_buf"></param>
            <param name="inlen"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake256_squeezeblocks(System.Byte[],System.Int32,System.Int32,PQnet.Digest.Shake.keccak_state)">
            <summary>
            Squeeze step of SHAKE256 XOF. Squeezes full blocks of SHAKE256_RATE bytes each.
            </summary>
            <param name="out_buf"></param>
            <param name="out_buf_pos"></param>
            <param name="nblocks"></param>
            <param name="state"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake128(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            SHAKE128 XOF with non-incremental API.
            </summary>
            <param name="out_buf"></param>
            <param name="outlen"></param>
            <param name="in_buf"></param>
            <param name="inlen"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.shake256(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            SHAKE256 XOF with non-incremental API.
            </summary>
            <param name="out_buf"></param>
            <param name="outlen"></param>
            <param name="in_buf"></param>
            <param name="inlen"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.sha3_256(System.Byte[]@,System.Byte[],System.Int32)">
            <summary>
            SHA3-256 with non-incremental API.
            </summary>
            <param name="h"></param>
            <param name="in_buf"></param>
            <param name="inlen"></param>
        </member>
        <member name="M:PQnet.Digest.Shake.sha3_512(System.Byte[]@,System.Byte[],System.Int32)">
            <summary>
            SHA3-512 with non-incremental API.
            </summary>
            <param name="h"></param>
            <param name="in_buf"></param>
            <param name="inlen"></param>
        </member>
        <member name="T:PQnet.AddressType">
            <summary>
            FIPS 205 Section 4.2 - Enumeration of the different types of addresses used in the SLH-DSA algorithm.
            </summary>
        </member>
        <member name="F:PQnet.AddressType.WotsHash">
            <summary>
             WOTS+ hash address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.WotsPk">
            <summary>
            WOTS+ public key address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.Tree">
            <summary>
            Hash tree address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.ForsTree">
            <summary>
            FORS tree address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.ForsRoots">
            <summary>
            FOTS tree roots compression address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.WotsPrf">
            <summary>
            WOTS+ key generation address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.ForsPrf">
            <summary>
            FORS key generation address
            </summary>
        </member>
        <member name="T:PQnet.IAddress">
            <summary>
            FIPS 205 Section 4.3 ADRS Member Functions
            </summary>
        </member>
        <member name="M:PQnet.IAddress.Clone">
            <summary>
            Clone the address
            </summary>
            <returns></returns>
        </member>
        <member name="M:PQnet.IAddress.SetLayerAddress(System.UInt32)">
            <summary>
            The the layer value
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:PQnet.IAddress.SetTreeAddress(System.UInt64)">
            <summary>
            Set the tree value
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:PQnet.IAddress.SetTypeAndClear(PQnet.AddressType)">
            <summary>
            Set the type and clear the rest of the address
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:PQnet.IAddress.SetKeyPairAddress(System.UInt32)">
            <summary>
            Set the key pair value
            </summary>
            <param name="keyPair"></param>
        </member>
        <member name="M:PQnet.IAddress.SetChainAddress(System.UInt32)">
            <summary>
            Set the chain value
            </summary>
            <param name="chain"></param>
        </member>
        <member name="M:PQnet.IAddress.SetTreeHeight(System.UInt32)">
            <summary>
            Set the tree height
            </summary>
            <param name="treeHeight"></param>
        </member>
        <member name="M:PQnet.IAddress.SetHashAddress(System.UInt32)">
            <summary>
            Set the hash
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:PQnet.IAddress.SetTreeIndex(System.UInt32)">
            <summary>
            Set the tree index
            </summary>
            <param name="treeIndex"></param>
        </member>
        <member name="P:PQnet.IAddress.TreeIndex">
            <summary>
            Get the tree index
            </summary>
        </member>
        <member name="P:PQnet.IAddress.KeyPairAddress">
            <summary>
            Get the key pair value
            </summary>
        </member>
        <member name="P:PQnet.IAddress.Bytes">
            <summary>
            The the full address
            </summary>
        </member>
        <member name="T:PQnet.IHashAlgorithm">
            <summary>
            FIPS 205 Section 4.1 - Hash Functions and Pseudo-Random Functions
            </summary>
        </member>
        <member name="M:PQnet.IHashAlgorithm.prf_msg(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            A pseudorandom function (PRF) that generates the randomizer() for the randomized hashing of the message to be signed.
            </summary>
            <param name="sk_prf"></param>
            <param name="opt_rand"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.h_msg(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Used to generate the digest of the message to be signed.
            </summary>
            <param name="r"></param>
            <param name="pk_seed"></param>
            <param name="pk_root"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.prf(System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            A PRF that is used to generate the secret values in WOTS+ and FORS private keys.
            </summary>
            <param name="pk_seed"></param>
            <param name="sk_seed"></param>
            <param name="adrs"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.t_len(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            A hash function that maps an -byte message to an -byte message.
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_l"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.h(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            A special case of T that takes a 2-byte message as input.
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_2"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.f(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            A hash function that takes an -byte message as input and produces an -byte output.
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_1"></param>
            <returns></returns>
        </member>
        <member name="P:PQnet.IHashAlgorithm.Name">
            <summary>
            Gets the name of the hash algorithm.
            </summary>
        </member>
        <member name="P:PQnet.IHashAlgorithm.IsShake">
            <summary>
            Gets a value indicating whether the hash algorithm is a SHAKE function.
            </summary>
        </member>
        <member name="T:PQnet.Sha2Address">
            <summary>
            FIPS 205 Section 11.2 ADRS Implementation for SHA2
            </summary>
        </member>
        <member name="M:PQnet.Sha2Address.#ctor">
            <summary>
            Instantiates a new object of class <see cref="T:PQnet.Sha2Address"/> 
            </summary>
        </member>
        <member name="P:PQnet.Sha2Address.Bytes">
            <summary>
            ADRS[0:22]
            </summary>
        </member>
        <member name="P:PQnet.Sha2Address.TreeIndex">
            <summary>
              toInt(ADRS[18  22], 4)
            </summary>
        </member>
        <member name="P:PQnet.Sha2Address.KeyPairAddress">
            <summary>
              toInt(ADRS[10  14], 4)
            </summary>
        </member>
        <member name="M:PQnet.Sha2Address.Clone">
            <summary>
            Returns a clone of the current <see cref="T:PQnet.Sha2Address"/>
            </summary>
            <returns>The cloned <see cref="T:PQnet.Sha2Address"/></returns>
        </member>
        <member name="M:PQnet.Sha2Address.SetChainAddress(System.UInt32)">
            <summary>
            ADRS  ADRS[0  14]  toByte(, 4)  ADRS[18  22]
            </summary>
            <param name="chain"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetHashAddress(System.UInt32)">
            <summary>
            ADRS  ADRS[0  18]  toByte(, 4)
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetKeyPairAddress(System.UInt32)">
            <summary>
            ADRS  ADRS[0  10]  toByte(, 4)  ADRS[14  22]
            </summary>
            <param name="keyPair"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetLayerAddress(System.UInt32)">
            <summary>
            ADRS  toByte(, 1)  ADRS[1  22]
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetTreeAddress(System.UInt64)">
            <summary>
            ADRS  ADRS[0  1]  toByte(, 8)  ADRS[9  22]
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetTreeHeight(System.UInt32)">
            <summary>
            ADRS  ADRS[0  14]  toByte(, 4)  ADRS[18  22]
            </summary>
            <param name="treeHeight"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetTreeIndex(System.UInt32)">
            <summary>
            ADRS  ADRS[0  18]  toByte(, 4)
            </summary>
            <param name="treeIndex"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetTypeAndClear(PQnet.AddressType)">
            <summary>
            ADRS  ADRS[0  9]  toByte( , 1)  toByte(0, 12)
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:PQnet.ShakeAddress">
            <summary>
            FIPS 205 Section 4.3 ADRS Implement for SHAKE
            </summary>
        </member>
        <member name="M:PQnet.ShakeAddress.#ctor">
            <summary>
            Instantiates a new object of class <see cref="T:PQnet.Sha2Address"/>
            </summary>
        </member>
        <member name="P:PQnet.ShakeAddress.Bytes">
            <summary>
            ADRS[0:22]
            </summary>
        </member>
        <member name="P:PQnet.ShakeAddress.TreeIndex">
            <summary>
              toInt(ADRS[28  32], 4)
            </summary>
        </member>
        <member name="P:PQnet.ShakeAddress.KeyPairAddress">
            <summary>
              toInt(ADRS[20  24], 4)
            </summary>
        </member>
        <member name="M:PQnet.ShakeAddress.SetChainAddress(System.UInt32)">
            <summary>
            ADRS  ADRS[0  24]  toByte(, 4)  ADRS[28  32]
            </summary>
            <param name="chain"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetHashAddress(System.UInt32)">
            <summary>
            ADRS  ADRS[0  28]  toByte(, 4)
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetKeyPairAddress(System.UInt32)">
            <summary>
            ADRS  ADRS[0  20]  toByte(, 4)  ADRS[24  32]
            </summary>
            <param name="keyPair"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetLayerAddress(System.UInt32)">
            <summary>
            ADRS  toByte(, 4)  ADRS[4  32]
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetTreeAddress(System.UInt64)">
            <summary>
            ADRS  ADRS[0  4]  toByte(, 12)  ADRS[16  32]
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetTreeHeight(System.UInt32)">
            <summary>
            ADRS  ADRS[0  24]  toByte(, 4)  ADRS[28  32]
            </summary>
            <param name="treeHeight"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetTreeIndex(System.UInt32)">
            <summary>
            ADRS  ADRS[0  28]  toByte(, 4)
            </summary>
            <param name="treeIndex"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetTypeAndClear(PQnet.AddressType)">
            <summary>
            ADRS  ADRS[0  16]  toByte( , 4)  toByte(0, 12)
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:PQnet.ShakeHash">
            <summary>
            FIPS 205 Section 11.1 SHAKE
            </summary>
        </member>
        <member name="M:PQnet.ShakeHash.f(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            SHAKE256(PK.seed  ADRS  1, 8)
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_1"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.h(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            SHAKE256(PK.seed  ADRS  2, 8)
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_2"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.h_msg(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            SHAKE256(  PK.seed  PK.root   , 8)
            </summary>
            <param name="r"></param>
            <param name="pk_seed"></param>
            <param name="pk_root"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.prf(System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            SHAKE256(PK.seed  ADRS  SK.seed, 8)
            </summary>
            <param name="pk_seed"></param>
            <param name="sk_seed"></param>
            <param name="adrs"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.prf_msg(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            SHAKE256(SK.prf  _   , 8)
            </summary>
            <param name="sk_prf"></param>
            <param name="opt_rand"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.t_len(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            SHAKE256(PK.seed  ADRS  2, 8)
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_l"></param>
            <returns></returns>
        </member>
        <member name="T:PQnet.SlhDsaBase">
            <summary>
            Base class for SLH-DSA signature schemes
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a SLH-DSA key pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
        </member>
        <member name="M:PQnet.SlhDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a SLH-DSA key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a SLH-DSA key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
            <remarks>
            If <paramref name="seed"/> is provided, it must be exactly <see cref="P:PQnet.SlhDsaBase.SeedBytes"/> bytes long.
            </remarks>
        </member>
        <member name="M:PQnet.SlhDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
        </member>
        <member name="M:PQnet.SlhDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.ArgumentException">Context was larger than 255 bytes</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.SignHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.ArgumentException">The provided hash function <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.ArgumentException">Context was larger than 255 bytes, or the provided hash function is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@,System.String@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes</exception>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.String@)">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.VerifyHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes</exception>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[],System.String@)">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.#ctor(PQnet.IHashAlgorithm,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.SlhDsaBase"/> class.
            </summary>
            <param name="hash"></param>
            <param name="n"></param>
            <param name="h"></param>
            <param name="d"></param>
            <param name="hp"></param>
            <param name="a"></param>
            <param name="k"></param>
            <param name="lg_w"></param>
            <param name="m"></param>
        </member>
        <member name="P:PQnet.SlhDsaBase.Deterministic">
            <summary>
            Gets or sets whether signature generation is deterministic
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.SeedBytes">
            <summary>
            Gets the size, in bytes, of the seed used for key generation
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.SignatureBytes">
            <summary>
            Gets the size, in bytes, of the signature
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.Name">
            <summary>
            Gets the name of the algorithm
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.NistSecurityCategory">
            <summary>
            Gets the NIST security category of the cryptographic algorithm.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaBase.toInt(System.Byte[],System.Int32)">
            <summary>
            FIPS 205 Algorithm 2 
            </summary>
            <param name="x"></param>
            <param name="n"></param>
        </member>
        <member name="M:PQnet.SlhDsaBase.toByte(System.Int64,System.Int32)">
            <summary>
            FIPS 205 Algorithm 3 
            </summary>
            <param name="x">integer</param>
            <param name="n">length</param>
        </member>
        <member name="M:PQnet.SlhDsaBase.base_2b(System.Byte[],System.Int32,System.UInt32)">
            <summary>
            FIPS 205 Algorithm 4 - Computes the base 2 representation of .
            </summary>
            <param name="x">Byte string  of length at least _ / 8 </param>
            <param name="b">Integer</param>
            <param name="out_len">output length</param>
            <returns>Array of _ integers in the range[0,  , 2  1]</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.chain(System.Byte[],System.Int32,System.Int32,System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 5 - Chaining function used in WOTS+
            </summary>
            <param name="x">Input string</param>
            <param name="i">Start index</param>
            <param name="s">Number of steps</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>Value of F iterated  times on </returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.wots_pkGen(System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 6 - Generates a WOTS+ public key
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>WOTS+ public key </returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.wots_sign(System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 7 - Generates a WOTS+ signature on an -byte message
            </summary>
            <param name="m">Message</param>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>WOTS+ signature </returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.wots_pkFromSig(System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 8 - Computes a WOTS+ public key from a message and its signature
            </summary>
            <param name="sig">WOTS+ signature</param>
            <param name="m">Message</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>WOTS+ public key  derived from </returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.xmss_node(System.Byte[],System.Int64,System.Int64,System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 9 - Computes the root of a Merkle subtree of WOTS+ public keys
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="i">Target node index</param>
            <param name="z">Target node height</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>-byte root </returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.xmss_sign(System.Byte[],System.Byte[],System.Int64,System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 10 - Generates an XMSS signature
            </summary>
            <param name="m">-byte message</param>
            <param name="sk_seed">Secret seed</param>
            <param name="idx">Index</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>XMSS signature SIG = (  AUTH)</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.xmss_pkFromSig(System.Int64,System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 11 - Computes an XMSS public key from an XMSS signature
            </summary>
            <param name="idx">Index</param>
            <param name="sig_xmss">XMSS signature SIG = (  AUTH)</param>
            <param name="m">-byte message</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>-byte root value [0]</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.ht_sign(System.Byte[],System.Byte[],System.Byte[],System.Int64,System.Int64)">
            <summary>
            FIPS 205 Algorithm 12 - Generates a hypertree signature
            </summary>
            <param name="m">Message</param>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="idx_tree">Tree index</param>
            <param name="idx_leaf">Leaf index</param>
            <returns>HT signature SIG</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.ht_verify(System.Byte[],System.Byte[],System.Byte[],System.Int64,System.Int64,System.Byte[])">
            <summary>
            FIPS 205 Algorithm 13 - Verifies a hypertree signature
            </summary>
            <param name="m">Message</param>
            <param name="sig_ht">Signature SIG</param>
            <param name="pk_seed">Public seed</param>
            <param name="idx_tree">Tree index</param>
            <param name="idx_leaf">Leaf index</param>
            <param name="pk_root">HT public key</param>
            <returns><c>true</c> if the signature is correct, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.fors_skGen(System.Byte[],System.Byte[],PQnet.IAddress,System.Int32)">
            <summary>
            FIPS 205 Algorithm 14 - Generates a FORS private-key value
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <param name="idx">Secret key index</param>
            <returns>-byte FORS private-key value</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.fors_node(System.Byte[],System.Int32,System.Int32,System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 15 - Computes the root of a Merkle subtree of FORS public values
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="i">Target node index</param>
            <param name="z">Target node height</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>-byte root </returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.fors_sign(System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 16 - Generates a FORS signature
            </summary>
            <param name="md">Message digest</param>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>FORS signature SIG</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.fors_pkFromSig(System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 17 - Computes a FORS public key from a FORS signature
            </summary>
            <param name="sig_fors">FORS signature SIG</param>
            <param name="md">Message digest</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>FORS public key</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_keygen_internal(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 18 - Generates an SLH-DSA key pair
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="sk_prf">PRF key</param>
            <param name="pk_seed">Public seed</param>
            <returns>SLH-DSA key pair (SK, PK)</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_sign_internal(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 19 - Generates an SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sk">Private key (SK.seed, SK.prf, PK.seed, PK.root)</param>
            <param name="addrnd">Additional randomness, or <c>null</c></param>
            <returns>SLH-DSA signature SIG</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_verify_internal(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 20 - Verifies an SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sig">Signature</param>
            <param name="pk">Public key (PK.seed, PK.root)</param>
            <returns><c>true</c> if the signature is valid, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_keygen(System.Byte[]@,System.Byte[]@)">
            <summary>
            FIPS 205 Algorithm 21 - Generates an SLH-DSA key pair
            </summary>
            <param name="sk">Receives private key</param>
            <param name="pk">Receives public key</param>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_sign(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 22 - Generates a pure SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="sk">Private key</param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.hash_slh_sign(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            FIPS 205 Algorithm 23 - Generates a pre-hash SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="sk">Private key</param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 24 -	Verifies a pure SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sig">Signature</param>
            <param name="ctx">Context string</param>
            <param name="pk">Public key</param>
            <returns><c>true</c> if the signature is valid, <c>false</c> otherwise</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.hash_slh_verify(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            FIPS 205 Algorithm 25 - Verifies a pre-hash SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sig">Signature</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="pk">Public key</param>
            <returns><c>true</c> if the signature is valid, <c>false</c> otherwise</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.GetAddress">
            <summary>
            Gets an address appropriate for the chosen hash function
            </summary>
            <returns></returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.SplitSk(System.Byte[],System.Byte[]@,System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Split the private key into its components
            </summary>
            <param name="sk">Private key</param>
            <param name="sk_seed">Receives the secret seed</param>
            <param name="sk_prf">Receives the secret key PRF</param>
            <param name="pk_seed">Receives the public seed</param>
            <param name="pk_root">Receives the HT public key</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.SplitPk(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Split the public key into its components
            </summary>
            <param name="pk">Public key</param>
            <param name="pk_seed">Receives the public seed</param>
            <param name="pk_root">Receives the HT public key</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:PQnet.SlhDsaSha2_128f">
            <summary>
            Implements the SLH-DSA-SHA2-128f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_128f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_128f"/> object with non-deterministic signatures
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_128f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_128f"/> object.
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaSha2_128f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_128f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_128s">
            <summary>
            Implements the SLH-DSA-SHA2-128s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_128s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_128s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_128s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_128s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_128s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_128s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_192f">
            <summary>
            Implements the SLH-DSA-SHA2-192f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_192f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_192f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_192f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_192f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_192f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_192f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_192s">
            <summary>
            Implements the SLH-DSA-SHA2-192s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_192s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_192s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_192s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_192s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_192s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_192s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_256f">
            <summary>
            Implements the SLH-DSA-SHA2-256f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_256f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_256f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_256f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_256f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_256f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_256f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_256s">
            <summary>
            Implements the SLH-DSA-SHA2-256s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_256s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_256s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_256s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_256s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_256s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_256s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_128f">
            <summary>
            Implements the SLH-DSA-SHAKE-128f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_128f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_128f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_128f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_128f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_128f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_128f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_128s">
            <summary>
            Implements the SLH-DSA-SHAKE-128s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_128s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_128s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_128s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_128s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_128s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_128s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_192f">
            <summary>
            Implements the SLH-DSA-SHAKE-192f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_192f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_192f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_192f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_192f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_192f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_192f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_192s">
            <summary>
            Implements the SLH-DSA-SHAKE-192s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_192s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_192s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_192s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_192s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_192s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_192s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_256f">
            <summary>
            Implements the SLH-DSA-SHAKE-256f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_256f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_256f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_256f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_256f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_256f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_256f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_256s">
            <summary>
            Implements the SLH-DSA-SHAKE-256s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_256s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_256s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_256s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_256s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_256s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_256s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.Utility">
            <summary>
            FIPS 205 Section 4.4 Arrays, Byte Strings, and Integers
            </summary>
        </member>
        <member name="M:PQnet.Utility.toInt(System.Byte[],System.Int32)">
            <summary>
            FIPS 205 Algorithm 2 - Load a <see cref="T:System.UInt32"/> from a <see cref="T:System.Byte"/> array in big-endian order at offset <paramref name="offset"/>.
            </summary>
            <param name="b"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.Utility.toByte(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            FIPS 205 Algorithm 3 - Store a <see cref="T:System.UInt32"/> in a <see cref="T:System.Byte"/> array in big-endian order at offset <paramref name="offset"/>.
            </summary>
            <param name="b"></param>
            <param name="offset"></param>
            <param name="i"></param>
        </member>
        <member name="M:PQnet.Utility.toByte(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            FIPS 205 Algorithm 3 - Store a <see cref="T:System.UInt64"/> in a <see cref="T:System.Byte"/> array in big-endian order at offset <paramref name="offset"/>.
            </summary>
            <param name="b"></param>
            <param name="offset"></param>
            <param name="i"></param>
        </member>
    </members>
</doc>
