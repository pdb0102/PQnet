<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PQnet</name>
    </assembly>
    <members>
        <member name="T:PQnet.IEncapsulate">
            <summary>
            Interface for signature algorithms
            </summary>
        </member>
        <member name="P:PQnet.IEncapsulate.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.IEncapsulate.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.IEncapsulate.CiphertextBytes">
            <summary>
            Gets the size, in bytes, of the ciphertext
            </summary>
        </member>
        <member name="P:PQnet.IEncapsulate.Name">
            <summary>
            Gets name of the algorithm
            </summary>
        </member>
        <member name="M:PQnet.IEncapsulate.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:PQnet.IEncapsulate.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.IEncapsulate.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.IEncapsulate.Encapsulate(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Use the public (encapsulation) key to generate a shared secret key and an associated ciphertext.
            </summary>
            <param name="public_key">The public (encapsulation) key to use</param>
            <param name="shared_secret_key">Receives the shared secret key</param>
            <param name="ciphertext">Receives the ciphertet</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The public (encapsulation) key length did not match the required <see cref="P:PQnet.IEncapsulate.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.IEncapsulate.Encapsulate(System.Byte[],System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Use the public (encapsulation) key to generate a shared secret key and an associated ciphertext.
            </summary>
            <param name="public_key">The public (encapsulation) key to use</param>
            <param name="shared_secret_key">Receives the shared secret key</param>
            <param name="ciphertext">Receives the ciphertet</param>
            <param name="error">Receives an error description, or <c>null</c></param>
            <returns><c>true</c> on success, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.IEncapsulate.Decapsulate(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Use the private (decapsulation) key to produce a shared secret key from a ciphertext
            </summary>
            <param name="private_key">The private (decapsulation) key to use</param>
            <param name="ciphertext">The ciphertext</param>
            <param name="shared_secret_key">Receives the shared_secret key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The private (decapsulation) key length did not match the required <see cref="P:PQnet.IEncapsulate.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.IEncapsulate.Decapsulate(System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Use the private (decapsulation) key to produce a shared secret key from a ciphertext
            </summary>
            <param name="private_key">The private (decapsulation) key to use</param>
            <param name="ciphertext">The ciphertext</param>
            <param name="shared_secret_key">Receives the shared_secret key</param>
            <param name="error">Receives an error description, or <c>null</c></param>
            <returns><c>true</c> on success, <c>false</c> otherwise</returns>
        </member>
        <member name="T:PQnet.ISecurityCategory">
            <summary>
            Interface for cryptographic algorithms to indicate the NIST security category.
            </summary>
        </member>
        <member name="P:PQnet.ISecurityCategory.NistSecurityCategory">
            <summary>
            Gets the NIST security category of the cryptographic algorithm.
            </summary>
        </member>
        <member name="T:PQnet.ISignature">
            <summary>
            Interface for signature algorithms
            </summary>
        </member>
        <member name="P:PQnet.ISignature.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.ISignature.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.ISignature.SignatureBytes">
            <summary>
            Gets the size, in bytes, of the signature
            </summary>
        </member>
        <member name="P:PQnet.ISignature.Name">
            <summary>
            Gets name of the algorithm
            </summary>
        </member>
        <member name="M:PQnet.ISignature.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:PQnet.ISignature.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.Sign(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Private key length did not match the required <see cref="P:PQnet.ISignature.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or private key length did not match the required <see cref="P:PQnet.ISignature.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Generate a pure signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.SignHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Private key length did not match the required <see cref="P:PQnet.ISignature.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or private key length did not match the required <see cref="P:PQnet.ISignature.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@,System.String@)">
            <summary>
            Generate a signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.Verify(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Public key length did not match the required <see cref="P:PQnet.ISignature.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or the public key length did not match the required <see cref="P:PQnet.ISignature.PublicKeyBytes"/></exception>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.String@)">
            <summary>
            Verify a pure signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.ISignature.VerifyHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The public key length did not match the required <see cref="P:PQnet.ISignature.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or the public key length did not match the required <see cref="P:PQnet.ISignature.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.ISignature.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[],System.String@)">
            <summary>
            Verify a digest ("pre-hash") signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="T:PQnet.PreHashFunction">
            <summary>
            Pre-Hash Functions
             FIPS 204 Section 5.4.1
             FIPS 205 Section 10.2.2 
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA224">
            <summary>
            SHA-224
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA256">
            <summary>
            SHA-512
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA384">
            <summary>
            SHA-256
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA512">
            <summary>
            SHA-512
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA512_224">
            <summary>
            SHA-512/224
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA512_256">
            <summary>
            SHA-512/256
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA3_224">
            <summary>
            SHA3-224
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA3_256">
            <summary>
            SHA3-512
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA3_384">
            <summary>
            SHA3-256
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHA3_512">
            <summary>
            SHA3-512
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHAKE128">
            <summary>
            SHAKE-128
            </summary>
        </member>
        <member name="F:PQnet.PreHashFunction.SHAKE256">
            <summary>
            SHAKE-256
            </summary>
        </member>
        <member name="M:PQnet.PreHashUtility.GetPHm(PQnet.PreHashFunction,System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Calculate PHm and oid for pre-hash functions
            </summary>
            <param name="ph"></param>
            <param name="m"></param>
            <param name="oid"></param>
            <param name="ph_m"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:PQnet.Digest.KeccakBaseX4">
            <summary>
            A SIMD-optimized implementation of the Keccak algorithm that calculates 4 hashes in parallel.
            </summary>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.AddBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add (in GC(2), using bitwise exclusive OR) the bytes of <paramref name="interleaved_data"/> to the state for all instances for <paramref name="length"/> bytes.
            </summary>
            <param name="interleaved_data">The interleaved data to consume</param>
            <param name="interleaved_data_offset">The offset, in bytes, from the start of <paramref name="interleaved_data"/> to start consuming bytes</param>
            <param name="length">The number of bytes of <paramref name="interleaved_data"/> to consume.</param>
            <returns>The number of bytes processed from <paramref name="interleaved_data"/></returns>
            <remarks>
            The interleaved data is structured as follows:
            A ulong (8 bytes) for instance 0, followed by a ulong (8 bytes) for instance 1, followed by a ulong (8 bytes) for instance 2, followed by a ulong (8 bytes) for instance 3, 
            and then the next 32 bytes for the next set of instances, repeating <see cref="F:PQnet.Digest.KeccakBaseX4.lane_count"/> times
            </remarks>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.AddByte(System.Int32,System.Int32,System.Byte)">
            <summary>
            Add (in GC(2), using bitwise exclusive OR) the byte <paramref name="data"/> to the state at <paramref name="state_offset"/>.
            </summary>
            <param name="instance">The instance to which to add the byte (0-3)</param>
            <param name="data">The byte to consume</param>
            <param name="state_offset">Offset, in bytes, within the state</param>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.AddByteAll(System.Int32,System.Byte)">
            <summary>
            Add (in GC(2), using bitwise exclusive OR) the byte <paramref name="data"/> to the state at <paramref name="state_offset"/>.
            </summary>
            <param name="data">The byte to consume</param>
            <param name="state_offset">Offset, in bytes, within the state</param>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.AddBytes(System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Add (in GC(2), using bitwise exclusive OR) the bytes of <paramref name="data"/> to the state at <paramref name="state_offset"/> for <paramref name="length"/> bytes.
            </summary>
            <param name="instance">The instance to which to add the bytes (0-3)</param>
            <param name="state_offset">Offset, in bytes, within the state</param>
            <param name="data">The data to consume</param>
            <param name="length">The number of bytes of <paramref name="data"/> to consume</param>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.AddBytesAll(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add <paramref name="length"/> bytes from <paramref name="interleaved_data"/> to the state.
            </summary>
            <param name="interleaved_data"></param>
            <param name="interleaved_data_offset"></param>
            <param name="length"></param>
            <returns>The number of consumed bytes</returns>
            <remarks>
            This method should not be called if length is a whole block or more.
            </remarks>
        </member>
        <member name="F:PQnet.Digest.KeccakBaseX4.Shake128Rate">
            <summary>
            The SHAKE128 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBaseX4.Shake256Rate">
            <summary>
            The SHAKE256 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBaseX4.Sha3_224Rate">
            <summary>
            The SHA3-224 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBaseX4.Sha3_256Rate">
            <summary>
            The SHA3-256 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBaseX4.Sha3_384Rate">
            <summary>
            The SHA3-384 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBaseX4.Sha3_512Rate">
            <summary>
            The SHA3-512 lane size in bytes.
            </summary>
        </member>
        <member name="P:PQnet.Digest.KeccakBaseX4.IsSupported">
            <summary>
            Indicates if the SIMD-optimized SHAKE128, SHAKE256, SHA3-256, and SHA3-512 are supported.
            </summary>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.ExtractBytesAll(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Retrieve all states for all lanes
            </summary>
            <param name="output1">Buffer for output of the the first instance</param>
            <param name="output2">Buffer for output of the the second instance</param>
            <param name="output3">Buffer for output of the the third instance</param>
            <param name="output4">Buffer for output of the the fourth instance</param>
            <param name="output_offset">The offset into ouputx to start writing the extracted bytes</param>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.Fast_Block_Absorb(System.Byte[],System.Int32)">
            <summary>
            Loads 4 lanes of the state with the interleaved data, and permutes the state.
            </summary>
            <param name="interleaved_data">The interleaved data to consume</param>
            <param name="length">The number of bytes to consume from <paramref name="interleaved_data"/></param>
            <returns>The number of consumed bytes per lane</returns>
            <remarks>
            The interleaved data is structured as follows:
            A ulong (8 bytes) for instance 0, followed by a ulong (8 bytes) for instance 1, followed by a ulong (8 bytes) for instance 2, followed by a ulong (8 bytes) for instance 3, 
            and then the next 32 bytes for the next set of instances, repeating <see cref="F:PQnet.Digest.KeccakBaseX4.lane_count"/> times
            </remarks>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.InterleaveArrays(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Interleave four byte arrays into a single one for use by <see cref="T:PQnet.Digest.KeccakBaseX4"/>
            </summary>
            <param name="input1">The first array</param>
            <param name="input2">The second array</param>
            <param name="input3">The third array</param>
            <param name="input4">The fourth array</param>
            <param name="input_length">The maximum bytes to take from the input</param>
            <returns>An interleaved array, with 8 bytes from the first input, 8 from the second, third and fourth, then the next 8 bytes from the first, and so on</returns>
        </member>
        <member name="M:PQnet.Digest.KeccakBaseX4.PermuteAll_24rounds">
            <summary>
            Apply the Keccak permutation on all states in parallel.
            </summary>
        </member>
        <member name="T:PQnet.Digest.Sha3_224x4">
            <summary>
            Implementation of SHA3-224 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_224x4.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Sha3_224x4"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_224x4.ComputeHash(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Calculate 4 SHA3-224 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <returns>Tuple with four SHA3-224 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="M:PQnet.Digest.Sha3_224x4.ComputeHash(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Calculate 4 SHA3-224 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <param name="inlen">The number of bytes to absorb from each input</param>
            <returns>Tuple with four SHA3-224 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="T:PQnet.Digest.Sha3_256x4">
            <summary>
            Implementation of SHA3-256 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_256x4.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Sha3_256x4"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_256x4.ComputeHash(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Calculate 4 SHA3-256 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <returns>Tuple with four SHA3-256 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="M:PQnet.Digest.Sha3_256x4.ComputeHash(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Calculate 4 SHA3-256 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <param name="inlen">The number of bytes to absorb from each input</param>
            <returns>Tuple with four SHA3-256 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="T:PQnet.Digest.Sha3_384x4">
            <summary>
            Implementation of SHA3-384 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_384x4.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Sha3_384x4"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_384x4.ComputeHash(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Calculate 4 SHA3-384 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <returns>Tuple with four SHA3-384 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="M:PQnet.Digest.Sha3_384x4.ComputeHash(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Calculate 4 SHA3-384 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <param name="inlen">The number of bytes to absorb from each input</param>
            <returns>Tuple with four SHA3-384 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="T:PQnet.Digest.Sha3_512x4">
            <summary>
            Implementation of SHA3-512 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_512x4.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Sha3_512x4"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_512x4.ComputeHash(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Calculate 4 SHA3-512 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <returns>Tuple with four SHA3-512 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="M:PQnet.Digest.Sha3_512x4.ComputeHash(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Calculate 4 SHA3-512 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <param name="inlen">The number of bytes to absorb from each input</param>
            <returns>Tuple with four SHA3-512 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="T:PQnet.Digest.Shake128x4">
            <summary>
            Implementation of SHAKE-128 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake128x4.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Shake128x4"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake128x4.HashData(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Calculate 4 SHAKE128 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <param name="outlen">The desired length of the hash</param>
            <returns>Tuple with four SHAKE-128 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="T:PQnet.Digest.Shake256x4">
            <summary>
            Implementation of SHAKE-128 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake256x4.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Shake256x4"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake256x4.HashData(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Calculate 4 SHAKE256 hashes in parallel.
            </summary>
            <param name="input1">The data to digest for hash 1</param>
            <param name="input2">The data to digest for hash 2</param>
            <param name="input3">The data to digest for hash 3</param>
            <param name="input4">The data to digest for hash 4</param>
            <param name="outlen">The desired length of the hash</param>
            <returns>Tuple with four SHAKE-128 hashes for <paramref name="input1"/>, <paramref name="input2"/>, <paramref name="input3"/> and <paramref name="input4"/></returns>
        </member>
        <member name="T:PQnet.Digest.KeccakBase">
            <summary>
            Implements the FIPS 202 Secure Hash Algorithm Keccak (SHAKE) extendable-output base functionality
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.Shake128Rate">
            <summary>
            The SHAKE-128 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.Shake256Rate">
            <summary>
            The SHAKE-256 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.Sha3_224Rate">
            <summary>
            The SHA3-224 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.Sha3_256Rate">
            <summary>
            The SHA3-256 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.Sha3_384Rate">
            <summary>
            The SHA3-384 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.Sha3_512Rate">
            <summary>
            The SHA3-512 lane size in bytes.
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.state">
            <summary>
            The Keccak sponge state
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.pos">
            <summary>
            Position in current block
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.rate">
            <summary>
            Rate in bytes
            </summary>
        </member>
        <member name="F:PQnet.Digest.KeccakBase.prefix">
            <summary>
            Domain separator
            </summary>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.#ctor">
            <summary>
            Instantiates a new KeccakBase object
            </summary>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.StatePermute">
            <summary>
            Perform the Keccak F1600 permutation on the state
            </summary>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.Init">
            <summary>
            Initializes the Keccak state
            </summary>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.Absorb(System.Byte[],System.Int32)">
            <summary>
            Absorb data into the Keccak state
            </summary>
            <param name="in_buf">The data to absorb</param>
            <param name="inlen">The number of bytes to absorb from <paramref name="inlen"/></param>
            <returns>The new position in the current block</returns>
            <remarks>Updates the position in the current block</remarks>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.FinalizeAbsorb">
            <summary>
            Finalizes the absorb step
            </summary>
            <remarks>This method absorbs the prefix (domain separation byte) and end-marker into the state. Updates the position to the end of the current block.</remarks>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.Squeeze(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Squeeze data from the Keccak state
            </summary>
            <param name="out_buf">The buffer to store squeeded bytes</param>
            <param name="out_buf_pos">The index into <paramref name="out_buf"/> where to start storing squeezed bytes</param>
            <param name="outlen">The number of bytes to squeeze out</param>
            <returns>The new position in current block</returns>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.AbsorbOnce(System.Byte[],System.Int32)">
            <summary>
            Absorb data into the Keccak state and finalize the absorb step
            </summary>
            <param name="in_buf">The data to absorb</param>
            <param name="inlen">The number of bytes to absorb from <paramref name="in_buf"/></param>
            <remarks>Updates the position in the current block to the end of the block</remarks>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.SqueezeBlocks(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Squeeze full blocks of <see cref="F:PQnet.Digest.KeccakBase.rate"/> bytes each
            </summary>
            <param name="out_buf">The buffer to store squeeded bytes</param>
            <param name="out_buf_pos">The index into <paramref name="out_buf"/> where to start storing squeezed bytes</param>
            <param name="nblocks"></param>
            <returns>Number of bytes stored in <paramref name="out_buf"/></returns>
            <remarks>Starts squeezing at the beginning of the current block (assumes nothing has been squeezed from the current block yet). Can be called multiple times.</remarks>
        </member>
        <member name="M:PQnet.Digest.KeccakBase.Hash(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            One-shot compute of the hash of the input data
            </summary>
            <param name="out_buf">The buffer receiving the hash</param>
            <param name="outlen">The desired length of the hash</param>
            <param name="input">The data for which to compute the hash</param>
            <param name="inlen">The number of bytes to consume from <paramref name="input"/></param>
            <returns>The SHAKE hash for <paramref name="input"/></returns>
            <remarks>Resets any existing state on input</remarks>
        </member>
        <member name="T:PQnet.Digest.Sha3_224">
            <summary>
            Implementation of SHA3-224 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_224.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Sha3_224"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_224.ComputeHash(System.Byte[])">
            <summary>
            Compute the SHA3-224 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <returns>The SHA3-224 hash for <paramref name="input"/></returns>
        </member>
        <member name="M:PQnet.Digest.Sha3_224.ComputeHash(System.Byte[],System.Int32)">
            <summary>
            Compute the SHA3-224 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <param name="inlen">The number of bytes to absorb from <paramref name="input"/></param>
            <returns>The SHA3-224 hash for <paramref name="input"/></returns>
        </member>
        <member name="T:PQnet.Digest.Sha3_256">
            <summary>
            Implementation of SHA3-256 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_256.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Sha3_256"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_256.ComputeHash(System.Byte[])">
            <summary>
            Compute the SHA3-256 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <returns>The SHA3-256 hash for <paramref name="input"/></returns>
        </member>
        <member name="M:PQnet.Digest.Sha3_256.ComputeHash(System.Byte[],System.Int32)">
            <summary>
            Compute the SHA3-256 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <param name="inlen">The number of bytes to absorb from <paramref name="input"/></param>
            <returns>The SHA3-256 hash for <paramref name="input"/></returns>
        </member>
        <member name="T:PQnet.Digest.Sha3_384">
            <summary>
            Implementation of SHA3-384 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_384.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Sha3_384"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_384.ComputeHash(System.Byte[])">
            <summary>
            Compute the SHA3-384 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <returns>The SHA3-384 hash for <paramref name="input"/></returns>
        </member>
        <member name="M:PQnet.Digest.Sha3_384.ComputeHash(System.Byte[],System.Int32)">
            <summary>
            Compute the SHA3-384 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <param name="inlen">The number of bytes to absorb from <paramref name="input"/></param>
            <returns>The SHA3-384 hash for <paramref name="input"/></returns>
        </member>
        <member name="T:PQnet.Digest.Sha3_512">
            <summary>
            Implementation of SHA3-512 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_512.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Sha3_512"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Sha3_512.ComputeHash(System.Byte[])">
            <summary>
            Compute the SHA3-512 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <returns>The SHA3-512 hash for <paramref name="input"/></returns>
        </member>
        <member name="M:PQnet.Digest.Sha3_512.ComputeHash(System.Byte[],System.Int32)">
            <summary>
            Compute the SHA3-512 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <param name="inlen">The number of bytes to absorb from <paramref name="input"/></param>
            <returns>The SHA3-512 hash for <paramref name="input"/></returns>
        </member>
        <member name="T:PQnet.Digest.Shake128">
            <summary>
            Implementation of SHAKE-128 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake128.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Shake128"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake128.HashData(System.Byte[],System.Int32)">
            <summary>
            Compute the SHAKE-128 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <param name="outlen">The desired length of the hash</param>
            <returns>The SHAKE-128 hash for <paramref name="input"/></returns>
        </member>
        <member name="T:PQnet.Digest.Shake256">
            <summary>
            Implementation of SHAKE-256 Hash Algorithm
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake256.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.Digest.Shake256"/> class.
            </summary>
        </member>
        <member name="M:PQnet.Digest.Shake256.HashData(System.Byte[],System.Int32)">
            <summary>
            Compute the SHAKE-256 hash of the input data
            </summary>
            <param name="input">The data for which to compute the hash</param>
            <param name="outlen">The desired length of the hash</param>
            <returns>The SHAKE-256 hash for <paramref name="input"/></returns>
        </member>
        <member name="T:PQnet.MlDsa44">
            <summary>
            Implements the ML-DSA-44 signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa44.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa44"/> class with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa44.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa44"/> class.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.MlDsa44.Deterministic">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa44.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa44.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlDsa65">
            <summary>
            Implements the ML-DSA-65 signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa65.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa65"/> class with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa65.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa65"/> class.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.MlDsa65.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa65.Deterministic">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa65.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlDsa87">
            <summary>
            Implements the ML-DSA-87 signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa87.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa87"/> class with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.MlDsa87.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlDsa87"/> class.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.MlDsa87.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa87.Deterministic">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsa87.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlDsaBase">
            <summary>
            Base class for ML-DSA digital signature algorithms.
            </summary>
        </member>
        <member name="F:PQnet.MlDsaBase.SeedBytes">
            <summary>
            The size, in bytes, of the seed used for key generation
            </summary>
        </member>
        <member name="M:PQnet.MlDsaBase.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.MlDsaBase"/> class.
            </summary>
            <param name="K"></param>
            <param name="L"></param>
            <param name="Eta"></param>
            <param name="Tau"></param>
            <param name="Beta"></param>
            <param name="Gamma1"></param>
            <param name="Gamma2"></param>
            <param name="Omega"></param>
            <param name="CTildeBytes"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:PQnet.MlDsaBase.Deterministic">
            <summary>
            Gets whether the signature should be randomized or deterministic (predictable, same input causes same signature)
            </summary>
        </member>
        <member name="P:PQnet.MlDsaBase.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsaBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlDsaBase.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.MlDsaBase.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.MlDsaBase.SignatureBytes">
            <summary>
            Gets the size, in bytes, of the signature
            </summary>
        </member>
        <member name="M:PQnet.MlDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a ML-DSA key pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a ML-DSA key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a ML-DSA key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
            <remarks>
            If <paramref name="seed"/> is provided, it must be exactly <see cref="F:PQnet.MlDsaBase.SeedBytes"/> bytes long.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Private key length did not match the required <see cref="P:PQnet.MlDsaBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or private key length did not match the required <see cref="P:PQnet.MlDsaBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.SignHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Private key length did not match the required <see cref="P:PQnet.MlDsaBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or private key length did not match the required <see cref="P:PQnet.MlDsaBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@,System.String@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Public key length did not match the required <see cref="P:PQnet.MlDsaBase.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or the public key length did not match the required <see cref="P:PQnet.MlDsaBase.PublicKeyBytes"/></exception>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.String@)">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.VerifyHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The public key length did not match the required <see cref="P:PQnet.MlDsaBase.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes, or the public key length did not match the required <see cref="P:PQnet.MlDsaBase.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlDsaBase.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[],System.String@)">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.ntt(System.Int32[])">
            <summary>
            Forward NTT, in-place.
            </summary>
            <param name="a">input/output coefficient array</param>
            <remarks>
            No modular reduction is performed after additions or subtractions.
            Output vector is in bitreversed order.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.invntt_tomont(System.Int32[])">
            <summary>
            Inverse NTT and multiplication by Montgomery factor 2^32.
            </summary>
            <remarks>
            In-place. No modular reductions after additions or subtractions; input coefficients need to be smaller than
            Q in absolute value.Output coefficient are smaller than Q in absolute value
            </remarks>
            <param name="a"></param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_reduce(PQnet.MlDsaBase.Poly)">
            <summary>
            Inplace reduction of all coefficients of polynomial to representative in [-6283008,6283008].
            </summary>
            <param name="a">polynominal</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_caddq(PQnet.MlDsaBase.Poly)">
            <summary>
            For all coefficients of in/out polynomial add Q if coefficient is negative.
            </summary>
            <param name="a">polynominal</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_add(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Add polynomials. No modular reduction is performed.
            </summary>
            <param name="c">Output polynominal</param>
            <param name="a">First summand</param>
            <param name="b">Second summand</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_sub(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Subtract polynomials. No modular reduction is performed.
            </summary>
            <param name="c">Output polynominal</param>
            <param name="a">First polynominal</param>
            <param name="b">Second polynominal to be subtracted from first</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_shiftl(PQnet.MlDsaBase.Poly)">
            <summary>
            Multiply polynomial by 2^D without modular reduction. 
            </summary>
            <param name="a">Polynominal</param>
            <remarks>
            Multiply polynomial by 2^D without modular reduction. 
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_ntt(PQnet.MlDsaBase.Poly)">
            <summary>
            Inplace forward NTT. Coefficients can grow by 8*Q in absolute value.
            </summary>
            <param name="a">Polynominal</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_invntt_tomont(PQnet.MlDsaBase.Poly)">
            <summary>
            Inplace inverse NTT and multiplication by 2^{32}.
            </summary>
            <param name="a"></param>
            <remarks>
            Input coefficients need to be less than Q in absolute value and output coefficients are again bounded by Q.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_pointwise_montgomery(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Pointwise multiplication of polynomials in NTT domain representation and multiplication of resulting polynomial by 2^{-32}.
            </summary>
            <param name="c">Output polynominal</param>
            <param name="a">First polynominal</param>
            <param name="b">Second polynominal</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_power2round(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            For all coefficients c of the input polynomial, compute c0, c1 such that c mod Q = c1*2^D + c0 with -2^{D-1} &lt; c0 &lt;= 2^{D-1}. 
            </summary>
            <param name="a1">polynomial with coefficients c1</param>
            <param name="a0">polynomial with coefficients c0</param>
            <param name="a">input polynomial</param>
            <remarks>
            Assumes coefficients to be standard representatives.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_decompose(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            For all coefficients c of the input polynomial, compute high and low bits c0, c1 such c mod Q = c1*ALPHA + c0 with -ALPHA/2 &lt; c0 &lt;= ALPHA/2 except c1 = (Q-1)/ALPHA where we set c1 = 0 and -ALPHA/2 &lt;= c0 = c mod Q - Q &lt; 0.
            </summary>
            <param name="a1"></param>
            <param name="a0"></param>
            <param name="a"></param>
            <remarks>
            Assumes coefficients to be standard representatives.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_make_hint(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Compute hint polynomial. The coefficients of which indicate whether the low bits of the corresponding coefficient of the input polynomial overflow into the high bits.
            </summary>
            <param name="h">output hint polynomial</param>
            <param name="a0">low part of input polynomial</param>
            <param name="a1">high part of input polynomial</param>
            <returns>number of 1 bits</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_use_hint(PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly,PQnet.MlDsaBase.Poly)">
            <summary>
            Use hint polynomial to correct the high bits of a polynomial
            </summary>
            <param name="b">output polynomial with corrected high bits</param>
            <param name="a">input polynomial</param>
            <param name="h">input hint polynomial</param>
        </member>
        <member name="M:PQnet.MlDsaBase.poly_chknorm(PQnet.MlDsaBase.Poly,System.Int32)">
            <summary>
            Check infinity norm of polynomial against given bound.
            </summary>
            <param name="a">polynomial</param>
            <param name="B">norm bound</param>
            <returns>0 if norm is strictly smaller than B &lt;= (Q-1)/8 and 1 otherwise.</returns>
            <remarks>
            Assumes input coefficients were reduced by reduce32().
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.rej_uniform(System.Int32[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Sample uniformly random coefficients in [0, Q-1] by performing rejection sampling on array of random bytes
            </summary>
            <param name="a">output array</param>
            <param name="a_offset">offset in output array</param>
            <param name="len">number of coefficients to be sampled</param>
            <param name="buf">array of random bytes</param>
            <param name="buflen">length of array of random bytes</param>
            <returns></returns>
        </member>
        <member name="M:PQnet.MlDsaBase.montgomery_reduce(System.Int64)">
            <summary>
            Montgomery reduction; given a 64-bit integer a, computes 32-bit integer congruent to a * R^-1 mod Q,
            </summary>
            <param name="a">finite field element a</param>
            <returns>r</returns>
            <remarks>
            For finite field element a with -2^{31}Q &lt;= a &lt;= Q*2^31, compute r \equiv a*2^{-32} (mod Q) such that -Q &lt; r &lt; Q.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.reduce32(System.Int32)">
            <summary>
            Reduce a coefficient a mod Q.
            </summary>
            <param name="a">finite field element a</param>
            <returns>r</returns>
            <remarks>
            For finite field element a with a &lt;= 2^{31} - 2^{22} - 1, compute r \equiv a (mod Q) such that -6283008 &lt;= r &lt;= 6283008.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.caddq(System.Int32)">
            <summary>
            Add Q if input coefficient is negative.
            </summary>
            <param name="a">finite field element a</param>
            <returns>r</returns>
        </member>
        <member name="M:PQnet.MlDsaBase.freeze(System.Int32)">
            <summary>
            
            </summary>
            <param name="a">finite field element a</param>
            <returns>r</returns>
            <remarks>
            For finite field element a, compute standard representative r = a mod^+ Q.
            </remarks>
        </member>
        <member name="M:PQnet.MlDsaBase.hash_ml_sign(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction)">
            <summary>
            FIPS 204 Algorithm 4 - Generates a pre-hash ML-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="sk">Private key</param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.MlDsaBase.hash_ml_sign(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            FIPS 204 Algorithm 4 - Generates a pre-hash ML-DSA signature - Internal version for ACVP testing with randomness
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="sk">Private key</param>
            <param name="addrnd">Additional randomness, or <c>null</c></param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.MlDsaBase.hash_ml_verify(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            FIPS 204 Algorithm 8 - Verifies a pre-hash ML-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sig">Signature</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="pk">Public key</param>
            <returns><c>true</c> if the signature is valid, <c>false</c> otherwise</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="T:PQnet.MlKemBase">
            <summary>
            Base class for ML-KEM key encapsulation algorithms.
            </summary>
            <summary>
            Base class for ML-KEM key encapsulation algorithms.
            </summary>
        </member>
        <member name="M:PQnet.MlKemBase.crypto_kem_keypair(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="pk"></param>
            <param name="sk"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.MlKemBase.crypto_kem_enc(System.Byte[]@,System.Byte[]@,System.Byte[])">
            <summary>
            
            </summary>
            <param name="ct"></param>
            <param name="ss"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.MlKemBase.crypto_kem_dec(System.Byte[]@,System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="ss"></param>
            <param name="ct"></param>
            <param name="sk"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.MlKemBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a ML-KEM key pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
        </member>
        <member name="M:PQnet.MlKemBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a ML-KEM key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlKemBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a ML-KEM key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed ('d' || 'z') bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
            <remarks>
            If a seed is provided, it must be of 2 *<see cref="P:PQnet.MlKemBase.SeedBytes"/> bytes length.
            </remarks>
        </member>
        <member name="M:PQnet.MlKemBase.Encapsulate(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Use the public (encapsulation) key to generate a shared secret key and an associated ciphertext.
            </summary>
            <param name="public_key">The public (encapsulation) key to use</param>
            <param name="shared_secret_key">Receives the shared secret key</param>
            <param name="ciphertext">Receives the ciphertet</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The public (encapsulation) key length did not match the required <see cref="P:PQnet.MlKemBase.PublicKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlKemBase.Encapsulate(System.Byte[],System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Use the public (encapsulation) key to generate a shared secret key and an associated ciphertext.
            </summary>
            <param name="public_key">The public (encapsulation) key to use</param>
            <param name="shared_secret_key">Receives the shared secret key</param>
            <param name="ciphertext">Receives the ciphertet</param>
            <param name="error">Receives an error description, or <c>null</c></param>
            <returns><c>true</c> on success, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlKemBase.Decapsulate(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Use the private (decapsulation) key to produce a shared secret key from a ciphertext
            </summary>
            <param name="private_key">The private (decapsulation) key to use</param>
            <param name="ciphertext">The ciphertext</param>
            <param name="shared_secret_key">Receives the shared_secret key</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">The private (decapsulation) key length did not match the required <see cref="P:PQnet.MlKemBase.PrivateKeyBytes"/></exception>
        </member>
        <member name="M:PQnet.MlKemBase.Decapsulate(System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Use the private (decapsulation) key to produce a shared secret key from a ciphertext
            </summary>
            <param name="private_key">The private (decapsulation) key to use</param>
            <param name="ciphertext">The ciphertext</param>
            <param name="shared_secret_key">Receives the shared_secret key</param>
            <param name="error">Receives an error description, or <c>null</c></param>
            <returns><c>true</c> on success, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.MlKemBase.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.MlKemBase"/> class.
            </summary>
            <param name="k"></param>
            <param name="eta_1"></param>
            <param name="eta_2"></param>
            <param name="poly_compressed_bytes"></param>
            <param name="polyvec_compressed_bytes"></param>
        </member>
        <member name="P:PQnet.MlKemBase.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKemBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKemBase.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.MlKemBase.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.MlKemBase.CiphertextBytes">
            <summary>
            Gets the size, in bytes, of the ciphertext
            </summary>
        </member>
        <member name="P:PQnet.MlKemBase.SeedBytes">
            <summary>
            Gets the size, in bytes, of the seed used for key generation
            </summary>
        </member>
        <member name="T:PQnet.MlKem1024">
            <summary>
            Implements the ML-KEM-1024 encapsulation scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlKem1024.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlKem1024"/> class.
            </summary>
        </member>
        <member name="P:PQnet.MlKem1024.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKem1024.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlKem512">
            <summary>
            Implements the ML-KEM-512 encapsulation scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlKem512.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlKem512"/> class.
            </summary>
        </member>
        <member name="P:PQnet.MlKem512.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKem512.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.MlKem768">
            <summary>
            Implements the ML-KEM-768 encapsulation scheme.
            </summary>
        </member>
        <member name="M:PQnet.MlKem768.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:PQnet.MlKem768"/> class.
            </summary>
        </member>
        <member name="P:PQnet.MlKem768.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.MlKem768.Name">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.NamespaceDoc">
            <summary>
            The <c>PQnet</c> namespace contains classes and methods for post-quantum cryptographic algorithms.
            </summary>
        </member>
        <member name="T:PQnet.PQC">
            <summary>
            Provides access to various post-quantum cryptographic algorithms.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlKem512">
            <summary>
            Gets a ML-KEM-512 encapsulation scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlKem768">
            <summary>
            Gets a ML-KEM-768 encapsulation scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlKem1024">
            <summary>
            Gets a ML-KEM-1024 encapsulation scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlDsa44">
            <summary>
            Gets a ML-DSA-44 signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlDsa65">
            <summary>
            Gets a ML-DSA-65 signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.MlDsa87">
            <summary>
            Gets a ML-DSA-87 signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_128f">
            <summary>
            Gets a SLH-DSA-SHAKE-128f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_128s">
            <summary>
            Gets a SLH-DSA-SHAKE-128s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_192f">
            <summary>
            Gets a SLH-DSA-SHAKE-192f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_192s">
            <summary>
            Gets a SLH-DSA-SHAKE-192s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_256f">
            <summary>
            Gets a SLH-DSA-SHAKE-256f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaShake_256s">
            <summary>
            Gets a SLH-DSA-SHAKE-256s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_128f">
            <summary>
            Gets a SLH-DSA-SHAKE-128f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_128s">
            <summary>
            Gets a SLH-DSA-SHAKE-128s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_192f">
            <summary>
            Gets a SLH-DSA-SHAKE-192f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_192s">
            <summary>
            Gets a SLH-DSA-SHAKE-192s signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_256f">
            <summary>
            Gets a SLH-DSA-SHAKE-256f signature scheme object.
            </summary>
        </member>
        <member name="P:PQnet.PQC.SlhDsaSha2_256s">
            <summary>
            Gets a SLH-DSA-SHAKE-256s signature scheme object.
            </summary>
        </member>
        <member name="M:PQnet.PQC.GetSignatureAlgorithmInstance(System.String)">
            <summary>
            Return a signature scheme object.
            </summary>
            <param name="name">The name of the signature algorithm</param>
            <returns>An <see cref="T:PQnet.ISignature"/> representing the algorithm <paramref name="name"/></returns>
        </member>
        <member name="M:PQnet.PQC.GetEncapsulationAlgorithmInstance(System.String)">
            <summary>
            Return a encapsulation scheme object.
            </summary>
            <param name="name">The name of the encapsulation algorithm</param>
            <returns>An <see cref="T:PQnet.IEncapsulate"/> representing the algorithm <paramref name="name"/></returns>
        </member>
        <member name="T:PQnet.Rng">
            <summary>
            Cryptographically strong random number generator
            </summary>
        </member>
        <member name="M:PQnet.Rng.randombytes(System.Byte[]@,System.Int32)">
            <summary>
            Generates a random byte array
            </summary>
            <param name="out_buffer">The buffer to receive the random bytes</param>
            <param name="outlen">The number of bytes to generate</param>
        </member>
        <member name="T:PQnet.AddressType">
            <summary>
            FIPS 205 Section 4.2 - Enumeration of the different types of addresses used in the SLH-DSA algorithm.
            </summary>
        </member>
        <member name="F:PQnet.AddressType.WotsHash">
            <summary>
             WOTS+ hash address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.WotsPk">
            <summary>
            WOTS+ public key address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.Tree">
            <summary>
            Hash tree address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.ForsTree">
            <summary>
            FORS tree address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.ForsRoots">
            <summary>
            FOTS tree roots compression address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.WotsPrf">
            <summary>
            WOTS+ key generation address
            </summary>
        </member>
        <member name="F:PQnet.AddressType.ForsPrf">
            <summary>
            FORS key generation address
            </summary>
        </member>
        <member name="T:PQnet.IAddress">
            <summary>
            FIPS 205 Section 4.3 ADRS Member Functions
            </summary>
        </member>
        <member name="M:PQnet.IAddress.Clone">
            <summary>
            Clone the address
            </summary>
            <returns></returns>
        </member>
        <member name="M:PQnet.IAddress.SetLayerAddress(System.UInt32)">
            <summary>
            The the layer value
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:PQnet.IAddress.SetTreeAddress(System.UInt64)">
            <summary>
            Set the tree value
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:PQnet.IAddress.SetTypeAndClear(PQnet.AddressType)">
            <summary>
            Set the type and clear the rest of the address
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:PQnet.IAddress.SetKeyPairAddress(System.UInt32)">
            <summary>
            Set the key pair value
            </summary>
            <param name="keyPair"></param>
        </member>
        <member name="M:PQnet.IAddress.SetChainAddress(System.UInt32)">
            <summary>
            Set the chain value
            </summary>
            <param name="chain"></param>
        </member>
        <member name="M:PQnet.IAddress.SetTreeHeight(System.UInt32)">
            <summary>
            Set the tree height
            </summary>
            <param name="treeHeight"></param>
        </member>
        <member name="M:PQnet.IAddress.SetHashAddress(System.UInt32)">
            <summary>
            Set the hash
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:PQnet.IAddress.SetTreeIndex(System.UInt32)">
            <summary>
            Set the tree index
            </summary>
            <param name="treeIndex"></param>
        </member>
        <member name="P:PQnet.IAddress.TreeIndex">
            <summary>
            Get the tree index
            </summary>
        </member>
        <member name="P:PQnet.IAddress.KeyPairAddress">
            <summary>
            Get the key pair value
            </summary>
        </member>
        <member name="P:PQnet.IAddress.Bytes">
            <summary>
            The the full address
            </summary>
        </member>
        <member name="T:PQnet.IHashAlgorithm">
            <summary>
            FIPS 205 Section 4.1 - Hash Functions and Pseudo-Random Functions
            </summary>
        </member>
        <member name="M:PQnet.IHashAlgorithm.prf_msg(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            A pseudorandom function (PRF) that generates the randomizer(𝑅) for the randomized hashing of the message to be signed.
            </summary>
            <param name="sk_prf"></param>
            <param name="opt_rand"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.h_msg(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Used to generate the digest of the message to be signed.
            </summary>
            <param name="r"></param>
            <param name="pk_seed"></param>
            <param name="pk_root"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.prf(System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            A PRF that is used to generate the secret values in WOTS+ and FORS private keys.
            </summary>
            <param name="pk_seed"></param>
            <param name="sk_seed"></param>
            <param name="adrs"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.t_len(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            A hash function that maps an ℓ𝑛-byte message to an 𝑛-byte message.
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_l"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.h(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            A special case of Tℓ that takes a 2𝑛-byte message as input.
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_2"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.IHashAlgorithm.f(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            A hash function that takes an 𝑛-byte message as input and produces an 𝑛-byte output.
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_1"></param>
            <returns></returns>
        </member>
        <member name="P:PQnet.IHashAlgorithm.Name">
            <summary>
            Gets the name of the hash algorithm.
            </summary>
        </member>
        <member name="P:PQnet.IHashAlgorithm.IsShake">
            <summary>
            Gets a value indicating whether the hash algorithm is a SHAKE function.
            </summary>
        </member>
        <member name="T:PQnet.Sha2Address">
            <summary>
            FIPS 205 Section 11.2 ADRS Implementation for SHA2
            </summary>
        </member>
        <member name="M:PQnet.Sha2Address.#ctor">
            <summary>
            Instantiates a new object of class <see cref="T:PQnet.Sha2Address"/> 
            </summary>
        </member>
        <member name="P:PQnet.Sha2Address.Bytes">
            <summary>
            ADRS[0:22]
            </summary>
        </member>
        <member name="P:PQnet.Sha2Address.TreeIndex">
            <summary>
            𝑖 ← toInt(ADRS[18 ∶ 22], 4)
            </summary>
        </member>
        <member name="P:PQnet.Sha2Address.KeyPairAddress">
            <summary>
            𝑖 ← toInt(ADRS[10 ∶ 14], 4)
            </summary>
        </member>
        <member name="M:PQnet.Sha2Address.Clone">
            <summary>
            Returns a clone of the current <see cref="T:PQnet.Sha2Address"/>
            </summary>
            <returns>The cloned <see cref="T:PQnet.Sha2Address"/></returns>
        </member>
        <member name="M:PQnet.Sha2Address.SetChainAddress(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 14] ∥ toByte(𝑖, 4) ∥ ADRS[18 ∶ 22]
            </summary>
            <param name="chain"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetHashAddress(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 18] ∥ toByte(𝑖, 4)
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetKeyPairAddress(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 10] ∥ toByte(𝑖, 4) ∥ ADRS[14 ∶ 22]
            </summary>
            <param name="keyPair"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetLayerAddress(System.UInt32)">
            <summary>
            ADRS ← toByte(𝑙, 1) ∥ ADRS[1 ∶ 22]
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetTreeAddress(System.UInt64)">
            <summary>
            ADRS ← ADRS[0 ∶ 1] ∥ toByte(𝑡, 8) ∥ ADRS[9 ∶ 22]
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetTreeHeight(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 14] ∥ toByte(𝑖, 4) ∥ ADRS[18 ∶ 22]
            </summary>
            <param name="treeHeight"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetTreeIndex(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 18] ∥ toByte(𝑖, 4)
            </summary>
            <param name="treeIndex"></param>
        </member>
        <member name="M:PQnet.Sha2Address.SetTypeAndClear(PQnet.AddressType)">
            <summary>
            ADRS ← ADRS[0 ∶ 9] ∥ toByte(𝑌 , 1) ∥ toByte(0, 12)
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:PQnet.ShakeAddress">
            <summary>
            FIPS 205 Section 4.3 ADRS Implement for SHAKE
            </summary>
        </member>
        <member name="M:PQnet.ShakeAddress.#ctor">
            <summary>
            Instantiates a new object of class <see cref="T:PQnet.Sha2Address"/>
            </summary>
        </member>
        <member name="P:PQnet.ShakeAddress.Bytes">
            <summary>
            ADRS[0:22]
            </summary>
        </member>
        <member name="P:PQnet.ShakeAddress.TreeIndex">
            <summary>
            𝑖 ← toInt(ADRS[28 ∶ 32], 4)
            </summary>
        </member>
        <member name="P:PQnet.ShakeAddress.KeyPairAddress">
            <summary>
            𝑖 ← toInt(ADRS[20 ∶ 24], 4)
            </summary>
        </member>
        <member name="M:PQnet.ShakeAddress.SetChainAddress(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 24] ∥ toByte(𝑖, 4) ∥ ADRS[28 ∶ 32]
            </summary>
            <param name="chain"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetHashAddress(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 28] ∥ toByte(𝑖, 4)
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetKeyPairAddress(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 20] ∥ toByte(𝑖, 4) ∥ ADRS[24 ∶ 32]
            </summary>
            <param name="keyPair"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetLayerAddress(System.UInt32)">
            <summary>
            ADRS ← toByte(𝑙, 4) ∥ ADRS[4 ∶ 32]
            </summary>
            <param name="layer"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetTreeAddress(System.UInt64)">
            <summary>
            ADRS ← ADRS[0 ∶ 4] ∥ toByte(𝑡, 12) ∥ ADRS[16 ∶ 32]
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetTreeHeight(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 24] ∥ toByte(𝑖, 4) ∥ ADRS[28 ∶ 32]
            </summary>
            <param name="treeHeight"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetTreeIndex(System.UInt32)">
            <summary>
            ADRS ← ADRS[0 ∶ 28] ∥ toByte(𝑖, 4)
            </summary>
            <param name="treeIndex"></param>
        </member>
        <member name="M:PQnet.ShakeAddress.SetTypeAndClear(PQnet.AddressType)">
            <summary>
            ADRS ← ADRS[0 ∶ 16] ∥ toByte(𝑌 , 4) ∥ toByte(0, 12)
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:PQnet.ShakeHash">
            <summary>
            FIPS 205 Section 11.1 SHAKE
            </summary>
        </member>
        <member name="M:PQnet.ShakeHash.f(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            SHAKE256(PK.seed ∥ ADRS ∥ 𝑀1, 8𝑛)
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_1"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.h(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            SHAKE256(PK.seed ∥ ADRS ∥ 𝑀2, 8𝑛)
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_2"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.h_msg(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            SHAKE256(𝑅 ∥ PK.seed ∥ PK.root ∥ 𝑀 , 8𝑚)
            </summary>
            <param name="r"></param>
            <param name="pk_seed"></param>
            <param name="pk_root"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.prf(System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            SHAKE256(PK.seed ∥ ADRS ∥ SK.seed, 8𝑛)
            </summary>
            <param name="pk_seed"></param>
            <param name="sk_seed"></param>
            <param name="adrs"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.prf_msg(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            SHAKE256(SK.prf ∥ 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑 ∥ 𝑀 , 8𝑛)
            </summary>
            <param name="sk_prf"></param>
            <param name="opt_rand"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.ShakeHash.t_len(System.Byte[],PQnet.IAddress,System.Byte[])">
            <summary>
            SHAKE256(PK.seed ∥ ADRS ∥ 𝑀2, 8𝑛)
            </summary>
            <param name="pk_seed"></param>
            <param name="adrs"></param>
            <param name="m_l"></param>
            <returns></returns>
        </member>
        <member name="T:PQnet.SlhDsaBase">
            <summary>
            Base class for SLH-DSA signature schemes
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generates a SLH-DSA key pair. Throws if an error occurs
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
        </member>
        <member name="M:PQnet.SlhDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.String@)">
            <summary>
            Generates a SLH-DSA key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.GenerateKeyPair(System.Byte[]@,System.Byte[]@,System.Byte[],System.String@)">
            <summary>
            Generates a SLH-DSA key pair.
            </summary>
            <param name="public_key">Receives the public key</param>
            <param name="private_key">Receives the private key</param>
            <param name="seed">Optional seed bytes for generation, or <c>null</c>.</param>
            <param name="error">Receives any error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key pair was successfully generated, <c>false</c> otherwise</returns>
            <remarks>
            If <paramref name="seed"/> is provided, it must be exactly <see cref="P:PQnet.SlhDsaBase.SeedBytes"/> bytes long.
            </remarks>
        </member>
        <member name="M:PQnet.SlhDsaBase.DerivePublicFromPrivateKey(System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Derive an SLH-DSA public key from a private key
            </summary>
            <param name="private_key">The private key</param>
            <param name="public_key">Receives the public key</param>
            <param name="error">Receives an error that occurred, or <c>null</c></param>
            <returns><c>true</c> if the key was successfully returned, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
        </member>
        <member name="M:PQnet.SlhDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.ArgumentException">Context was larger than 255 bytes</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[]@,System.String@)">
            <summary>
            Generate a pure ML-DSA signature
            </summary>
            <param name="message">The message to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.SignHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <remarks>Uses an empty context string (ctx)</remarks>
            <exception cref="T:System.ArgumentException">The provided hash function <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <exception cref="T:System.ArgumentException">Context was larger than 255 bytes, or the provided hash function is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.SignHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[]@,System.String@)">
            <summary>
            Generate a ML-DSA signature for a digest ("pre-hash signature")
            </summary>
            <param name="digest">The message digest to sign</param>
            <param name="private_key">The private key to use for signing</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">Receives the signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the message was successfully signed, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes</exception>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.String@)">
            <summary>
            Verify a pure ML-DSA signature
            </summary>
            <param name="message">The message to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.VerifyHash(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException">Context was larger than 255 bytes</exception>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.VerifyHash(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[],System.String@)">
            <summary>
            Verify a digest ("pre-hash") ML-DSA signature
            </summary>
            <param name="digest">The message digest to authenticate</param>
            <param name="public_key">The public key to use for verification</param>
            <param name="ctx">The context string, or <c>null</c></param>
            <param name="ph">The hash function used to the create the message digest</param>
            <param name="signature">The message signature</param>
            <param name="error">Receives an error string on failure</param>
            <returns><c>true</c> if the signature is valid and the message authentic, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.#ctor(PQnet.IHashAlgorithm,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PQnet.SlhDsaBase"/> class.
            </summary>
            <param name="hash"></param>
            <param name="n"></param>
            <param name="h"></param>
            <param name="d"></param>
            <param name="hp"></param>
            <param name="a"></param>
            <param name="k"></param>
            <param name="lg_w"></param>
            <param name="m"></param>
        </member>
        <member name="P:PQnet.SlhDsaBase.Deterministic">
            <summary>
            Gets or sets whether signature generation is deterministic
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.PrivateKeyBytes">
            <summary>
            Gets the size, in bytes, of the private key
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.PublicKeyBytes">
            <summary>
            Gets the size, in bytes, of the public key
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.SeedBytes">
            <summary>
            Gets the size, in bytes, of the seed used for key generation
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.SignatureBytes">
            <summary>
            Gets the size, in bytes, of the signature
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.Name">
            <summary>
            Gets the name of the algorithm
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaBase.NistSecurityCategory">
            <summary>
            Gets the NIST security category of the cryptographic algorithm.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaBase.toInt(System.Byte[],System.Int32)">
            <summary>
            FIPS 205 Algorithm 2 
            </summary>
            <param name="x"></param>
            <param name="n"></param>
        </member>
        <member name="M:PQnet.SlhDsaBase.toByte(System.Int64,System.Int32)">
            <summary>
            FIPS 205 Algorithm 3 
            </summary>
            <param name="x">integer</param>
            <param name="n">length</param>
        </member>
        <member name="M:PQnet.SlhDsaBase.base_2b(System.Byte[],System.Int32,System.UInt32)">
            <summary>
            FIPS 205 Algorithm 4 - Computes the base 2𝑏 representation of 𝑋.
            </summary>
            <param name="x">Byte string 𝑋 of length at least ⌈𝑜𝑢𝑡_𝑙𝑒𝑛⋅𝑏 / 8 ⌉</param>
            <param name="b">Integer</param>
            <param name="out_len">output length</param>
            <returns>Array of 𝑜𝑢𝑡_𝑙𝑒𝑛 integers in the range[0, … , 2𝑏 − 1]</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.chain(System.Byte[],System.Int32,System.Int32,System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 5 - Chaining function used in WOTS+
            </summary>
            <param name="x">Input string</param>
            <param name="i">Start index</param>
            <param name="s">Number of steps</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>Value of F iterated 𝑠 times on 𝑋</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.wots_pkGen(System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 6 - Generates a WOTS+ public key
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>WOTS+ public key 𝑝𝑘</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.wots_sign(System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 7 - Generates a WOTS+ signature on an 𝑛-byte message
            </summary>
            <param name="m">Message</param>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>WOTS+ signature 𝑠𝑖𝑔</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.wots_pkFromSig(System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 8 - Computes a WOTS+ public key from a message and its signature
            </summary>
            <param name="sig">WOTS+ signature</param>
            <param name="m">Message</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>WOTS+ public key 𝑝𝑘𝑠𝑖𝑔 derived from 𝑠𝑖𝑔</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.xmss_node(System.Byte[],System.Int64,System.Int64,System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 9 - Computes the root of a Merkle subtree of WOTS+ public keys
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="i">Target node index</param>
            <param name="z">Target node height</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>𝑛-byte root 𝑛𝑜𝑑𝑒</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.xmss_sign(System.Byte[],System.Byte[],System.Int64,System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 10 - Generates an XMSS signature
            </summary>
            <param name="m">𝑛-byte message</param>
            <param name="sk_seed">Secret seed</param>
            <param name="idx">Index</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>XMSS signature SIG𝑋𝑀𝑆𝑆 = (𝑠𝑖𝑔 ∥ AUTH)</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.xmss_pkFromSig(System.Int64,System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 11 - Computes an XMSS public key from an XMSS signature
            </summary>
            <param name="idx">Index</param>
            <param name="sig_xmss">XMSS signature SIG𝑋𝑀𝑆𝑆 = (𝑠𝑖𝑔 ∥ AUTH)</param>
            <param name="m">𝑛-byte message</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>𝑛-byte root value 𝑛𝑜𝑑𝑒[0]</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.ht_sign(System.Byte[],System.Byte[],System.Byte[],System.Int64,System.Int64)">
            <summary>
            FIPS 205 Algorithm 12 - Generates a hypertree signature
            </summary>
            <param name="m">Message</param>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="idx_tree">Tree index</param>
            <param name="idx_leaf">Leaf index</param>
            <returns>HT signature SIG𝐻𝑇</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.ht_verify(System.Byte[],System.Byte[],System.Byte[],System.Int64,System.Int64,System.Byte[])">
            <summary>
            FIPS 205 Algorithm 13 - Verifies a hypertree signature
            </summary>
            <param name="m">Message</param>
            <param name="sig_ht">Signature SIG𝐻𝑇</param>
            <param name="pk_seed">Public seed</param>
            <param name="idx_tree">Tree index</param>
            <param name="idx_leaf">Leaf index</param>
            <param name="pk_root">HT public key</param>
            <returns><c>true</c> if the signature is correct, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.fors_skGen(System.Byte[],System.Byte[],PQnet.IAddress,System.Int32)">
            <summary>
            FIPS 205 Algorithm 14 - Generates a FORS private-key value
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <param name="idx">Secret key index</param>
            <returns>𝑛-byte FORS private-key value</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.fors_node(System.Byte[],System.Int32,System.Int32,System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 15 - Computes the root of a Merkle subtree of FORS public values
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="i">Target node index</param>
            <param name="z">Target node height</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>𝑛-byte root 𝑛𝑜𝑑𝑒</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.fors_sign(System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 16 - Generates a FORS signature
            </summary>
            <param name="md">Message digest</param>
            <param name="sk_seed">Secret seed</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>FORS signature SIG𝐹𝑂𝑅𝑆</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.fors_pkFromSig(System.Byte[],System.Byte[],System.Byte[],PQnet.IAddress)">
            <summary>
            FIPS 205 Algorithm 17 - Computes a FORS public key from a FORS signature
            </summary>
            <param name="sig_fors">FORS signature SIG𝐹𝑂𝑅𝑆</param>
            <param name="md">Message digest</param>
            <param name="pk_seed">Public seed</param>
            <param name="adrs">Address</param>
            <returns>FORS public key</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_keygen_internal(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 18 - Generates an SLH-DSA key pair
            </summary>
            <param name="sk_seed">Secret seed</param>
            <param name="sk_prf">PRF key</param>
            <param name="pk_seed">Public seed</param>
            <returns>SLH-DSA key pair (SK, PK)</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_sign_internal(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 19 - Generates an SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sk">Private key (SK.seed, SK.prf, PK.seed, PK.root)</param>
            <param name="addrnd">Additional randomness, or <c>null</c></param>
            <returns>SLH-DSA signature SIG</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_verify_internal(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 20 - Verifies an SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sig">Signature</param>
            <param name="pk">Public key (PK.seed, PK.root)</param>
            <returns><c>true</c> if the signature is valid, <c>false</c> otherwise</returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_keygen(System.Byte[]@,System.Byte[]@)">
            <summary>
            FIPS 205 Algorithm 21 - Generates an SLH-DSA key pair
            </summary>
            <param name="sk">Receives private key</param>
            <param name="pk">Receives public key</param>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_sign(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 22 - Generates a pure SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="sk">Private key</param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 22 - Generates a pure SLH-DSA signature - Internal version for ACVP testing with randomness
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="sk">Private key</param>
            <param name="addrnd">Additional randomness, or <c>null</c></param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.hash_slh_sign(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            FIPS 205 Algorithm 23 - Generates a pre-hash SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="sk">Private key</param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.hash_slh_sign(System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 23 - Generates a pre-hash SLH-DSA signature - Internal version for ACVP testing with randomness
            </summary>
            <param name="m">Message</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="sk">Private key</param>
            <param name="addrnd">Additional randomness, or <c>null</c></param>
            <returns>SLH-DSA signature SIG</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.slh_verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            FIPS 205 Algorithm 24 -	Verifies a pure SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sig">Signature</param>
            <param name="ctx">Context string</param>
            <param name="pk">Public key</param>
            <returns><c>true</c> if the signature is valid, <c>false</c> otherwise</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.hash_slh_verify(System.Byte[],System.Byte[],System.Byte[],PQnet.PreHashFunction,System.Byte[])">
            <summary>
            FIPS 205 Algorithm 25 - Verifies a pre-hash SLH-DSA signature
            </summary>
            <param name="m">Message</param>
            <param name="sig">Signature</param>
            <param name="ctx">Context string</param>
            <param name="ph">Pre-hash function</param>
            <param name="pk">Public key</param>
            <returns><c>true</c> if the signature is valid, <c>false</c> otherwise</returns>
            <exception cref="T:System.ArgumentException"><paramref name="ctx"/> is longer than 255 bytes, or <paramref name="ph"/> is not supported</exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.GetAddress">
            <summary>
            Gets an address appropriate for the chosen hash function
            </summary>
            <returns></returns>
        </member>
        <member name="M:PQnet.SlhDsaBase.SplitSk(System.Byte[],System.Byte[]@,System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Split the private key into its components
            </summary>
            <param name="sk">Private key</param>
            <param name="sk_seed">Receives the secret seed</param>
            <param name="sk_prf">Receives the secret key PRF</param>
            <param name="pk_seed">Receives the public seed</param>
            <param name="pk_root">Receives the HT public key</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:PQnet.SlhDsaBase.SplitPk(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Split the public key into its components
            </summary>
            <param name="pk">Public key</param>
            <param name="pk_seed">Receives the public seed</param>
            <param name="pk_root">Receives the HT public key</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:PQnet.SlhDsaSha2_128f">
            <summary>
            Implements the SLH-DSA-SHA2-128f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_128f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_128f"/> object with non-deterministic signatures
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_128f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_128f"/> object.
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
            </summary>
        </member>
        <member name="P:PQnet.SlhDsaSha2_128f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_128f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_128s">
            <summary>
            Implements the SLH-DSA-SHA2-128s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_128s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_128s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_128s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_128s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_128s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_128s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_192f">
            <summary>
            Implements the SLH-DSA-SHA2-192f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_192f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_192f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_192f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_192f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_192f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_192f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_192s">
            <summary>
            Implements the SLH-DSA-SHA2-192s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_192s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_192s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_192s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_192s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_192s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_192s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_256f">
            <summary>
            Implements the SLH-DSA-SHA2-256f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_256f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_256f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_256f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_256f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_256f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_256f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaSha2_256s">
            <summary>
            Implements the SLH-DSA-SHA2-256s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_256s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_256s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaSha2_256s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaSha2_256s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaSha2_256s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaSha2_256s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_128f">
            <summary>
            Implements the SLH-DSA-SHAKE-128f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_128f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_128f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_128f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_128f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_128f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_128f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_128s">
            <summary>
            Implements the SLH-DSA-SHAKE-128s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_128s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_128s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_128s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_128s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_128s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_128s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_192f">
            <summary>
            Implements the SLH-DSA-SHAKE-192f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_192f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_192f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_192f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_192f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_192f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_192f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_192s">
            <summary>
            Implements the SLH-DSA-SHAKE-192s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_192s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_192s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_192s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_192s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_192s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_192s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_256f">
            <summary>
            Implements the SLH-DSA-SHAKE-256f signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_256f.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_256f"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_256f.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_256f"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_256f.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_256f.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.SlhDsaShake_256s">
            <summary>
            Implements the SLH-DSA-SHAKE-256s signature scheme.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_256s.#ctor">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_256s"/> object with non-deterministic signatures.
            </summary>
        </member>
        <member name="M:PQnet.SlhDsaShake_256s.#ctor(System.Boolean)">
            <summary>
            Instantiates a new <see cref="T:PQnet.SlhDsaShake_256s"/> object.
            </summary>
            <param name="deterministic"><c>true</c> if generated signatures should be deterministic, <c>false</c> otherwise</param>
        </member>
        <member name="P:PQnet.SlhDsaShake_256s.Name">
            <inheritdoc/>
        </member>
        <member name="P:PQnet.SlhDsaShake_256s.NistSecurityCategory">
            <inheritdoc/>
        </member>
        <member name="T:PQnet.Utility">
            <summary>
            FIPS 205 Section 4.4 Arrays, Byte Strings, and Integers
            </summary>
        </member>
        <member name="M:PQnet.Utility.toInt(System.Byte[],System.Int32)">
            <summary>
            FIPS 205 Algorithm 2 - Load a <see cref="T:System.UInt32"/> from a <see cref="T:System.Byte"/> array in big-endian order at offset <paramref name="offset"/>.
            </summary>
            <param name="b"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:PQnet.Utility.toByte(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            FIPS 205 Algorithm 3 - Store a <see cref="T:System.UInt32"/> in a <see cref="T:System.Byte"/> array in big-endian order at offset <paramref name="offset"/>.
            </summary>
            <param name="b"></param>
            <param name="offset"></param>
            <param name="i"></param>
        </member>
        <member name="M:PQnet.Utility.toByte(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            FIPS 205 Algorithm 3 - Store a <see cref="T:System.UInt64"/> in a <see cref="T:System.Byte"/> array in big-endian order at offset <paramref name="offset"/>.
            </summary>
            <param name="b"></param>
            <param name="offset"></param>
            <param name="i"></param>
        </member>
    </members>
</doc>
